{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/dxx/source/css/highlight.css","path":"css/highlight.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/highlight.min.css","path":"css/highlight.min.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/monosocialiconsfont.css","path":"css/monosocialiconsfont.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/monosocialiconsfont.min.css","path":"css/monosocialiconsfont.min.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.woff","path":"fonts/MonoSocialIconsFont-1.10.woff","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/icons.svg","path":"fonts/icons.svg","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/icons.woff","path":"fonts/icons.woff","modified":1,"renderable":1},{"_id":"themes/dxx/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/dxx/source/images/avatar@2x.png","path":"images/avatar@2x.png","modified":1,"renderable":1},{"_id":"themes/dxx/source/js/index.js","path":"js/index.js","modified":1,"renderable":1},{"_id":"themes/dxx/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/dxx/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/dxx/source/js/jquery-3.3.1.min.js","path":"js/jquery-3.3.1.min.js","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.ttf","path":"fonts/MonoSocialIconsFont-1.10.ttf","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.svg","path":"fonts/MonoSocialIconsFont-1.10.svg","modified":1,"renderable":1},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/dxx/source/js/highlight.min.js","path":"js/highlight.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/dxx/LICENSE","hash":"507fb070f13c541d64433731f6ca891007303fc1","modified":1534750796000},{"_id":"themes/dxx/README.md","hash":"76eed282b75fe4193d6847ec5f2ce7beab4946c5","modified":1534750796000},{"_id":"themes/dxx/package.json","hash":"745dc4aedaf5eb9ac28b32ad5e49f4099434dec2","modified":1534750796000},{"_id":"themes/dxx/_config.yml","hash":"ba99958e41dc7a6189afbc468ad4ad5c2478d6a2","modified":1534757848000},{"_id":"source/_posts/Hexo-blog-framework.md","hash":"075829cc74bd78316d98162b9b3a95274b4286c4","modified":1535953950349},{"_id":"source/_posts/不可变对象.md","hash":"ace4b56d1e0d06fd7122c8fb66dfc4db71f71fbd","modified":1535964340531},{"_id":"source/_posts/安全发布对象.md","hash":"e28d4363bb20eb5d61a98657619e5e4c7017d0dc","modified":1535964253671},{"_id":"source/_posts/并发基本概念.md","hash":"814df556b17a51d82512e06bd2e8b81eb17321fb","modified":1535619976110},{"_id":"source/_posts/并发模拟.md","hash":"a6899840165283377b255ac41f35478d89bc1115","modified":1535694488789},{"_id":"source/_posts/线程安全性-原子性.md","hash":"946f967b8d3b519e0e828f0019f259b94ad1aab4","modified":1535953950353},{"_id":"source/_posts/线程安全性-可见性.md","hash":"c0d8f1588bb16837d912293eb37c57d32dd394f2","modified":1535953950354},{"_id":"source/_posts/线程安全性-有序性.md","hash":"0de6335324fd076c8e8db97d8f90f9ae2f3ebc93","modified":1535953950359},{"_id":"themes/dxx/layout/archive.pug","hash":"a847b51ac26b4828f57299becbc6b8b4fdb8ffa0","modified":1534750796000},{"_id":"themes/dxx/layout/index.pug","hash":"30d4396269ab0aeddd48bde74fe16e9d0c815d9c","modified":1534750796000},{"_id":"themes/dxx/layout/post.pug","hash":"c8d7f926add037a9f9f7b6b3bda23db361f604ba","modified":1534750796000},{"_id":"source/_posts/Hexo-blog-framework/github_config.png","hash":"3914dcd0557322845e5ab5e45660d14910201441","modified":1535683554701},{"_id":"source/_posts/并发基本概念/MESI_protocal.jpg","hash":"e2f43a4ddffb607d6edfd8cbbfef04697dc17345","modified":1535619397340},{"_id":"themes/dxx/layout/includes/after_footer.pug","hash":"8bbfffea7787ad51b9a81ef0cea81805556978ea","modified":1534750796000},{"_id":"themes/dxx/layout/includes/disqus.pug","hash":"03fdca9127b7a4f8a1fe298331077f0f158f9f8c","modified":1534750796000},{"_id":"themes/dxx/layout/includes/footer.pug","hash":"6935250e9acfc633172207cfcf813e80b14eb243","modified":1534755044000},{"_id":"themes/dxx/layout/includes/googleAnalytics.pug","hash":"8f827dd7505012c17b98c029a476aa2c152a1e22","modified":1534750796000},{"_id":"themes/dxx/layout/includes/layout.pug","hash":"69c4a54f06787b4d2776458bb88b4326ee15c0ce","modified":1534750796000},{"_id":"themes/dxx/layout/includes/head.pug","hash":"6834384bbf1c8e6d6f353896cc5cd58add7a2480","modified":1534762946000},{"_id":"themes/dxx/layout/includes/nav.pug","hash":"57a681c15da4fd40ae564da7301964c11b82122b","modified":1534750796000},{"_id":"themes/dxx/layout/includes/profile.pug","hash":"4320981f954bcecb2da0368f1274585914956f75","modified":1534762940000},{"_id":"themes/dxx/source/css/highlight.css","hash":"1afe807bfb7d7ed2568e8637bd10352c9a13f358","modified":1534750796000},{"_id":"themes/dxx/source/css/highlight.min.css","hash":"afb4f1d3e8917b812e013034470f444491b47bd9","modified":1534750796000},{"_id":"themes/dxx/source/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1534750796000},{"_id":"themes/dxx/source/css/monosocialiconsfont.css","hash":"83154fcbf731bccdb247824dc540d804044c3f5b","modified":1534750796000},{"_id":"themes/dxx/source/css/monosocialiconsfont.min.css","hash":"d2818e282e540257dffdbbf997fa272c30541507","modified":1534750796000},{"_id":"themes/dxx/source/css/style.css","hash":"0695e19c635d08dfd02c4f3a5eaa14b05457cbd2","modified":1534750796000},{"_id":"themes/dxx/source/css/style.min.css","hash":"d95762020cc919367de30bc559e8fd005d3c8a0d","modified":1534750796000},{"_id":"themes/dxx/layout/includes/comment.pug","hash":"00ce36b299134870d9225ef6d91271d41f92f79e","modified":1534750796000},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.woff","hash":"8755dcf98f0896705d8f84cd9746407c67065727","modified":1534750796000},{"_id":"themes/dxx/source/fonts/icons.svg","hash":"4b05214485b496cf7ca5e1059fa5009b5584c0c1","modified":1534750796000},{"_id":"themes/dxx/source/fonts/icons.ttf","hash":"b78addb6c6c3275c5c62369279e908e2bf03e76b","modified":1534750796000},{"_id":"themes/dxx/source/fonts/icons.woff","hash":"fb24eafcd20cfff29a8d6c59d1ce6c8b2c6456d1","modified":1534750796000},{"_id":"themes/dxx/source/images/avatar.png","hash":"4709534d1b796240bf76d0b93a3fdd681b53fdbe","modified":1534750796000},{"_id":"themes/dxx/source/images/avatar@2x.png","hash":"4709534d1b796240bf76d0b93a3fdd681b53fdbe","modified":1534750796000},{"_id":"themes/dxx/source/js/index.js","hash":"23ec645f7c823d565003d803f6e8b13b193f716f","modified":1534750796000},{"_id":"themes/dxx/source/js/jquery.tagcloud.js","hash":"839487d0cbb4b6b498036bf3ecf6c3fd0a7482c4","modified":1534750796000},{"_id":"themes/dxx/source/js/main.js","hash":"9709660bc1bbd5bf053403dbe48f33787762c706","modified":1534750796000},{"_id":"source/_posts/并发基本概念/JMM_caozuo.png","hash":"118e6c9d5cffc5211c7a5de9e6be12eb4a0fdf57","modified":1535619397337},{"_id":"source/_posts/线程安全性-可见性/reorder_read.png","hash":"b0c9932c9b6b88a7caeeaa2d761ac94b1aa87d0e","modified":1535953950356},{"_id":"source/_posts/线程安全性-可见性/reorder_write.png","hash":"9c162d3134cd703b65e814db373c0cd823227eb7","modified":1535953950358},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1534750796000},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1534750796000},{"_id":"themes/dxx/source/js/jquery-3.3.1.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1534750796000},{"_id":"source/_posts/并发基本概念/JMM.png","hash":"19403feb41f0823df0467df31b4cc2076f5f6b58","modified":1535619397335},{"_id":"themes/dxx/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1534750796000},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.ttf","hash":"20b5d5c509123ad6f693d4f859684a606baa5109","modified":1534750796000},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1534750796000},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1534750796000},{"_id":"themes/dxx/source/fonts/MonoSocialIconsFont-1.10.svg","hash":"8fc9a4fa016790ad7fc20a80c96d23b3c889000a","modified":1534750796000},{"_id":"themes/dxx/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1534750796000},{"_id":"themes/dxx/source/js/highlight.min.js","hash":"4e152b54b8a2809077d0618033cba0918a9a6de7","modified":1534750796000},{"_id":"source/_posts/并发基本概念/ad_disad.png","hash":"00d7d4fe1133acc9567065dd4020f3c542074ca7","modified":1535619397350},{"_id":"public/2018/09/03/不可变对象/index.html","hash":"041ccb0e4c7bda8cf27fe924c31fa5eb08a34202","modified":1535964462757},{"_id":"public/2018/09/02/安全发布对象/index.html","hash":"18f39f39070f190b7c8effe0b3dcb8bb5427f609","modified":1535964462757},{"_id":"public/2018/09/02/线程安全性-有序性/index.html","hash":"92a8b2584326aa9aee7e4cc2fbba0a4026a17a95","modified":1535964462757},{"_id":"public/2018/09/01/线程安全性-可见性/index.html","hash":"6594aa873976c195ec64a9d828652a6616ae1d00","modified":1535964462757},{"_id":"public/2018/08/31/线程安全性-原子性/index.html","hash":"fc6fc0d73742c1c7ba7eb71d034842907bef1640","modified":1535964462757},{"_id":"public/2018/08/30/并发模拟/index.html","hash":"6e172283ad9890ebd21dcd4ac88f96257d699b0b","modified":1535964462757},{"_id":"public/2018/08/29/并发基本概念/index.html","hash":"3a4420723d2e9b51a4fa6b7efe94866d99b7475c","modified":1535964462757},{"_id":"public/2018/08/20/Hexo-blog-framework/index.html","hash":"268b48c6c7c2037705267d05c9cbea9af443be2a","modified":1535964462757},{"_id":"public/archives/index.html","hash":"045a31cb0aa2e422a211b2c959fdcf7518fa47cf","modified":1535964462758},{"_id":"public/archives/2018/index.html","hash":"045a31cb0aa2e422a211b2c959fdcf7518fa47cf","modified":1535964462758},{"_id":"public/archives/2018/08/index.html","hash":"045a31cb0aa2e422a211b2c959fdcf7518fa47cf","modified":1535964462758},{"_id":"public/archives/2018/09/index.html","hash":"045a31cb0aa2e422a211b2c959fdcf7518fa47cf","modified":1535964462758},{"_id":"public/index.html","hash":"ad212cdeee83df176bca45beb22cf9be6d0a710b","modified":1535964462758},{"_id":"public/fonts/MonoSocialIconsFont-1.10.woff","hash":"8755dcf98f0896705d8f84cd9746407c67065727","modified":1535964462767},{"_id":"public/fonts/icons.ttf","hash":"b78addb6c6c3275c5c62369279e908e2bf03e76b","modified":1535964462767},{"_id":"public/images/avatar.png","hash":"4709534d1b796240bf76d0b93a3fdd681b53fdbe","modified":1535964462767},{"_id":"public/images/avatar@2x.png","hash":"4709534d1b796240bf76d0b93a3fdd681b53fdbe","modified":1535964462767},{"_id":"public/fonts/icons.svg","hash":"4b05214485b496cf7ca5e1059fa5009b5584c0c1","modified":1535964462767},{"_id":"public/fonts/icons.woff","hash":"fb24eafcd20cfff29a8d6c59d1ce6c8b2c6456d1","modified":1535964462767},{"_id":"public/2018/08/20/Hexo-blog-framework/github_config.png","hash":"3914dcd0557322845e5ab5e45660d14910201441","modified":1535964462767},{"_id":"public/2018/08/29/并发基本概念/MESI_protocal.jpg","hash":"e2f43a4ddffb607d6edfd8cbbfef04697dc17345","modified":1535964462768},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535964462774},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535964462775},{"_id":"public/2018/08/29/并发基本概念/JMM_caozuo.png","hash":"118e6c9d5cffc5211c7a5de9e6be12eb4a0fdf57","modified":1535964462777},{"_id":"public/2018/09/01/线程安全性-可见性/reorder_read.png","hash":"b0c9932c9b6b88a7caeeaa2d761ac94b1aa87d0e","modified":1535964462778},{"_id":"public/2018/09/01/线程安全性-可见性/reorder_write.png","hash":"9c162d3134cd703b65e814db373c0cd823227eb7","modified":1535964462778},{"_id":"public/css/highlight.css","hash":"1afe807bfb7d7ed2568e8637bd10352c9a13f358","modified":1535964462782},{"_id":"public/css/highlight.min.css","hash":"afb4f1d3e8917b812e013034470f444491b47bd9","modified":1535964462782},{"_id":"public/css/monosocialiconsfont.css","hash":"83154fcbf731bccdb247824dc540d804044c3f5b","modified":1535964462782},{"_id":"public/css/monosocialiconsfont.min.css","hash":"d2818e282e540257dffdbbf997fa272c30541507","modified":1535964462783},{"_id":"public/css/style.min.css","hash":"d95762020cc919367de30bc559e8fd005d3c8a0d","modified":1535964462783},{"_id":"public/css/style.css","hash":"0695e19c635d08dfd02c4f3a5eaa14b05457cbd2","modified":1535964462783},{"_id":"public/js/index.js","hash":"04460c4d2be494b361958f2a7a28e85ed2a530a6","modified":1535964462783},{"_id":"public/js/jquery.tagcloud.js","hash":"45f7625f93128ec1fd0319dbc691de0936866e85","modified":1535964462784},{"_id":"public/js/main.js","hash":"4d6e423fb5556c8376c51184664150ccf8557c47","modified":1535964462784},{"_id":"public/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535964462784},{"_id":"public/js/jquery-3.3.1.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1535964462784},{"_id":"public/js/highlight.min.js","hash":"45151d184f32b36eb762126d068f6568ae99231e","modified":1535964462784},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535964462784},{"_id":"public/fonts/MonoSocialIconsFont-1.10.ttf","hash":"20b5d5c509123ad6f693d4f859684a606baa5109","modified":1535964462786},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535964462786},{"_id":"public/2018/08/29/并发基本概念/JMM.png","hash":"19403feb41f0823df0467df31b4cc2076f5f6b58","modified":1535964462786},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535964462787},{"_id":"public/fonts/MonoSocialIconsFont-1.10.svg","hash":"8fc9a4fa016790ad7fc20a80c96d23b3c889000a","modified":1535964462792},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1535964462812},{"_id":"public/2018/08/29/并发基本概念/ad_disad.png","hash":"00d7d4fe1133acc9567065dd4020f3c542074ca7","modified":1535964462901}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"不可变对象","date":"2018-09-03T08:45:40.000Z","_content":"","source":"_posts/不可变对象.md","raw":"---\ntitle: 不可变对象\ndate: 2018-09-03 16:45:40\ntags:\n---\n","slug":"不可变对象","published":1,"updated":"2018-09-03T08:45:40.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l02x0000hcr05jz9iol4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"安全发布对象","date":"2018-09-02T02:49:35.000Z","_content":"\n# 基本概念\n1. 发布对象： 使一个对象能够被当前范围之外的代码所使用\n2. 对象逸出： 一种错误的发布， 当一个对象还没构造完成时， 就使它被其他线程所见\n\n# 安全发布的方法\n1. 在静态初始化函数中初始化一个对象引用\n2. 将对象的引用保存在volatile类型域或者AtomicReference对象中\n3. 将对象的引用保存在某个正确构造对象的final类型域中\n4. 将对象的引用保存在一个由锁保护的域中\n\n## 单例模式发布对象\n1. 懒汉模式（通过加锁来确保线程安全， 第一次使用到单例实例的时候进行创建）\n\n// 双重同步锁检测机制不是线程安全的\n// 1. memory = allocate() 分配对象内存空间\n// 2. ctorInstance() 初始化对象\n// 3. instance = memory 设置instance指向刚分配的内存\n// JVM和cpu优化， 发生了指令重拍\n// 1. memory = allocate() 分配对象内存空间\n// 3. instance = memory 设置instance指向刚分配的内存\n// 2. ctorInstance() 初始化对象\n// 线程A执行到3， 线程B会以为instance已经创建好了， 实际上还没有初始化\n\n     // 单例对象\n    private static SingletonExample1 instance = null;\n\n    // 静态的工厂方法\n    public static SingletonExample1 getInstance(){\n        if(instance == null){ //双重检测机制\n            synchronized (SingletonExample2.class) {\n                if (instance == null) {\n                    instance = new SingletonExample1();\n                }\n            }\n        }\n        return instance;\n    }\n\n    *所以单例对象要加volatile， 总结下， volatile使用场景， 一个是状态表示量， 一个是双重检测*   \n\n2. 饿汉模式（线程安全，单例实例在类装载的时候进行创建）\n\n可以通过静态域或者静态块的方式， 单例模式构造方法为private， 防止程序其他地方调用构造方法\n\t\n\tprivate SingletonExample2(){ }\n    public static SingletonExample2 instance = null;\n    static{\n        instance = new SingletonExample2();\n    }\n    public SingletonExample2 getInstance(){\n        return instance;\n    }\n\n3. 枚举模式\n\n\tpublic class SingletonExample3 {\n    \tprivate SingletonExample3(){ }\n    \tpublic static SingletonExample3 getInstance(){\n      \t  return Singleton.INSTANCE.getInstance();\n    \t}\n    \tprivate enum Singleton {\n        \tINSTANCE;\n        \tprivate SingletonExample3 singletonExample;\n\t        // JVM 保证这个方法绝对只调用一次\n    \t    Singleton(){\n        \t    singletonExample = new SingletonExample3();\n        \t}\n        \tpublic SingletonExample3 getInstance(){\n            \treturn singletonExample;\n        \t}\n    \t}\n\t}\n\n最安全， 同时像饿汉模式一样在类加载时候初始化","source":"_posts/安全发布对象.md","raw":"---\ntitle: 安全发布对象\ndate: 2018-09-02 10:49:35\ntags:\n---\n\n# 基本概念\n1. 发布对象： 使一个对象能够被当前范围之外的代码所使用\n2. 对象逸出： 一种错误的发布， 当一个对象还没构造完成时， 就使它被其他线程所见\n\n# 安全发布的方法\n1. 在静态初始化函数中初始化一个对象引用\n2. 将对象的引用保存在volatile类型域或者AtomicReference对象中\n3. 将对象的引用保存在某个正确构造对象的final类型域中\n4. 将对象的引用保存在一个由锁保护的域中\n\n## 单例模式发布对象\n1. 懒汉模式（通过加锁来确保线程安全， 第一次使用到单例实例的时候进行创建）\n\n// 双重同步锁检测机制不是线程安全的\n// 1. memory = allocate() 分配对象内存空间\n// 2. ctorInstance() 初始化对象\n// 3. instance = memory 设置instance指向刚分配的内存\n// JVM和cpu优化， 发生了指令重拍\n// 1. memory = allocate() 分配对象内存空间\n// 3. instance = memory 设置instance指向刚分配的内存\n// 2. ctorInstance() 初始化对象\n// 线程A执行到3， 线程B会以为instance已经创建好了， 实际上还没有初始化\n\n     // 单例对象\n    private static SingletonExample1 instance = null;\n\n    // 静态的工厂方法\n    public static SingletonExample1 getInstance(){\n        if(instance == null){ //双重检测机制\n            synchronized (SingletonExample2.class) {\n                if (instance == null) {\n                    instance = new SingletonExample1();\n                }\n            }\n        }\n        return instance;\n    }\n\n    *所以单例对象要加volatile， 总结下， volatile使用场景， 一个是状态表示量， 一个是双重检测*   \n\n2. 饿汉模式（线程安全，单例实例在类装载的时候进行创建）\n\n可以通过静态域或者静态块的方式， 单例模式构造方法为private， 防止程序其他地方调用构造方法\n\t\n\tprivate SingletonExample2(){ }\n    public static SingletonExample2 instance = null;\n    static{\n        instance = new SingletonExample2();\n    }\n    public SingletonExample2 getInstance(){\n        return instance;\n    }\n\n3. 枚举模式\n\n\tpublic class SingletonExample3 {\n    \tprivate SingletonExample3(){ }\n    \tpublic static SingletonExample3 getInstance(){\n      \t  return Singleton.INSTANCE.getInstance();\n    \t}\n    \tprivate enum Singleton {\n        \tINSTANCE;\n        \tprivate SingletonExample3 singletonExample;\n\t        // JVM 保证这个方法绝对只调用一次\n    \t    Singleton(){\n        \t    singletonExample = new SingletonExample3();\n        \t}\n        \tpublic SingletonExample3 getInstance(){\n            \treturn singletonExample;\n        \t}\n    \t}\n\t}\n\n最安全， 同时像饿汉模式一样在类加载时候初始化","slug":"安全发布对象","published":1,"updated":"2018-09-03T08:44:13.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l0320001hcr077ew49u2","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>发布对象： 使一个对象能够被当前范围之外的代码所使用</li>\n<li>对象逸出： 一种错误的发布， 当一个对象还没构造完成时， 就使它被其他线程所见</li>\n</ol>\n<h1 id=\"安全发布的方法\"><a href=\"#安全发布的方法\" class=\"headerlink\" title=\"安全发布的方法\"></a>安全发布的方法</h1><ol>\n<li>在静态初始化函数中初始化一个对象引用</li>\n<li>将对象的引用保存在volatile类型域或者AtomicReference对象中</li>\n<li>将对象的引用保存在某个正确构造对象的final类型域中</li>\n<li>将对象的引用保存在一个由锁保护的域中</li>\n</ol>\n<h2 id=\"单例模式发布对象\"><a href=\"#单例模式发布对象\" class=\"headerlink\" title=\"单例模式发布对象\"></a>单例模式发布对象</h2><ol>\n<li>懒汉模式（通过加锁来确保线程安全， 第一次使用到单例实例的时候进行创建）</li>\n</ol>\n<p>// 双重同步锁检测机制不是线程安全的<br>// 1. memory = allocate() 分配对象内存空间<br>// 2. ctorInstance() 初始化对象<br>// 3. instance = memory 设置instance指向刚分配的内存<br>// JVM和cpu优化， 发生了指令重拍<br>// 1. memory = allocate() 分配对象内存空间<br>// 3. instance = memory 设置instance指向刚分配的内存<br>// 2. ctorInstance() 初始化对象<br>// 线程A执行到3， 线程B会以为instance已经创建好了， 实际上还没有初始化</p>\n<pre><code> // 单例对象\nprivate static SingletonExample1 instance = null;\n\n// 静态的工厂方法\npublic static SingletonExample1 getInstance(){\n    if(instance == null){ //双重检测机制\n        synchronized (SingletonExample2.class) {\n            if (instance == null) {\n                instance = new SingletonExample1();\n            }\n        }\n    }\n    return instance;\n}\n\n*所以单例对象要加volatile， 总结下， volatile使用场景， 一个是状态表示量， 一个是双重检测*   \n</code></pre><ol start=\"2\">\n<li>饿汉模式（线程安全，单例实例在类装载的时候进行创建）</li>\n</ol>\n<p>可以通过静态域或者静态块的方式， 单例模式构造方法为private， 防止程序其他地方调用构造方法</p>\n<pre><code>private SingletonExample2(){ }\npublic static SingletonExample2 instance = null;\nstatic{\n    instance = new SingletonExample2();\n}\npublic SingletonExample2 getInstance(){\n    return instance;\n}\n</code></pre><ol start=\"3\">\n<li><p>枚举模式</p>\n<p> public class SingletonExample3 {</p>\n<pre><code>private SingletonExample3(){ }\npublic static SingletonExample3 getInstance(){\n    return Singleton.INSTANCE.getInstance();\n}\nprivate enum Singleton {\n    INSTANCE;\n    private SingletonExample3 singletonExample;\n    // JVM 保证这个方法绝对只调用一次\n    Singleton(){\n        singletonExample = new SingletonExample3();\n    }\n    public SingletonExample3 getInstance(){\n        return singletonExample;\n    }\n}\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>最安全， 同时像饿汉模式一样在类加载时候初始化</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>发布对象： 使一个对象能够被当前范围之外的代码所使用</li>\n<li>对象逸出： 一种错误的发布， 当一个对象还没构造完成时， 就使它被其他线程所见</li>\n</ol>\n<h1 id=\"安全发布的方法\"><a href=\"#安全发布的方法\" class=\"headerlink\" title=\"安全发布的方法\"></a>安全发布的方法</h1><ol>\n<li>在静态初始化函数中初始化一个对象引用</li>\n<li>将对象的引用保存在volatile类型域或者AtomicReference对象中</li>\n<li>将对象的引用保存在某个正确构造对象的final类型域中</li>\n<li>将对象的引用保存在一个由锁保护的域中</li>\n</ol>\n<h2 id=\"单例模式发布对象\"><a href=\"#单例模式发布对象\" class=\"headerlink\" title=\"单例模式发布对象\"></a>单例模式发布对象</h2><ol>\n<li>懒汉模式（通过加锁来确保线程安全， 第一次使用到单例实例的时候进行创建）</li>\n</ol>\n<p>// 双重同步锁检测机制不是线程安全的<br>// 1. memory = allocate() 分配对象内存空间<br>// 2. ctorInstance() 初始化对象<br>// 3. instance = memory 设置instance指向刚分配的内存<br>// JVM和cpu优化， 发生了指令重拍<br>// 1. memory = allocate() 分配对象内存空间<br>// 3. instance = memory 设置instance指向刚分配的内存<br>// 2. ctorInstance() 初始化对象<br>// 线程A执行到3， 线程B会以为instance已经创建好了， 实际上还没有初始化</p>\n<pre><code> // 单例对象\nprivate static SingletonExample1 instance = null;\n\n// 静态的工厂方法\npublic static SingletonExample1 getInstance(){\n    if(instance == null){ //双重检测机制\n        synchronized (SingletonExample2.class) {\n            if (instance == null) {\n                instance = new SingletonExample1();\n            }\n        }\n    }\n    return instance;\n}\n\n*所以单例对象要加volatile， 总结下， volatile使用场景， 一个是状态表示量， 一个是双重检测*   \n</code></pre><ol start=\"2\">\n<li>饿汉模式（线程安全，单例实例在类装载的时候进行创建）</li>\n</ol>\n<p>可以通过静态域或者静态块的方式， 单例模式构造方法为private， 防止程序其他地方调用构造方法</p>\n<pre><code>private SingletonExample2(){ }\npublic static SingletonExample2 instance = null;\nstatic{\n    instance = new SingletonExample2();\n}\npublic SingletonExample2 getInstance(){\n    return instance;\n}\n</code></pre><ol start=\"3\">\n<li><p>枚举模式</p>\n<p> public class SingletonExample3 {</p>\n<pre><code>private SingletonExample3(){ }\npublic static SingletonExample3 getInstance(){\n    return Singleton.INSTANCE.getInstance();\n}\nprivate enum Singleton {\n    INSTANCE;\n    private SingletonExample3 singletonExample;\n    // JVM 保证这个方法绝对只调用一次\n    Singleton(){\n        singletonExample = new SingletonExample3();\n    }\n    public SingletonExample3 getInstance(){\n        return singletonExample;\n    }\n}\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>最安全， 同时像饿汉模式一样在类加载时候初始化</p>\n"},{"title":"并发基本概念","date":"2018-08-29T07:59:58.000Z","_content":"\n## 基本概念\n\n并发： 同时拥有两个或者多个线程， 如果程序在单核处理器上运行， 多个线程将交替地换入或者换出内存， 这些线程是同时“存在”的，每个线程处于执行过程中的某个状态， 如果运行在多核处理器上， 此时每个线程都能分配到一个处理器核上， 因此可以同时运行。\n\n高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一， 它通常是指， 通过设计保证系统能够**同时并行处理**很多请求。\n\n\n## CPU多级缓存\n\nCPU频率太快， 主存跟不上， 这样在处理器时钟周期内， CPU常常需要等待主存， 浪费资源。 cache出现， 是为了缓解CPU和主存之间速度不匹配 **（速度 cpu > cache > memory）**.\n\n### 缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：\n\t\n\t* 时间局部性： 如果某个数据被访问， 那么不久将来也会被访问\n\t* 空间局部性： 如果某个数据被访问， 那么与它相邻的数据很快会被访问\n\n### cpu多级缓存 - 缓存一致性（MESI协议）\n\nMESI协议为了保证多个CPU cache之间缓存共享数据的一致性， 缓存控制器监听本地和远程操作的时候需要对地址一定的cache line状态做出修改。\n\n![MESI Protocal](MESI_protocal.jpg)\n\n#### 四个状态\n\n1. Modified: 该缓存行只被缓存在该CPU的缓存中，并且是被修改过（dirty），与主存的数据不一致。在允许其它CPU读取主存中相应内存之前需要写回（write back）主存。 写回后该缓存行状态变为独享（exclusive）状态。\n2. Exclusive：该缓存行只被缓存在该CPU的缓存中， 未被修改。 和主存数据一致。任何时候在其它CPU读取内存时变为共享状态（shared）。\n3. Shared：该缓存行被多个CPU缓存，各个缓存中数据与主存一致， 当一个CPU修改该缓存行， 其它CPU中该缓存行可以被作废（Invalid）\n4. Invalid：该缓存是无效的。\n\n#### 四种操作\n\n1. Local read: 读本地缓存中的数据 \n2. Local write: 数据写入本地缓存\n3. Remote read: 读取主存中的数据\n4. Remote write: 数据写回主存\n\n### 乱序执行优化\n\n处理器为提高运算速度而做出违背代码原有顺序的优化。 举个例子：\n一个核上执行数据准备操作，最后写一个标记表示准备就绪。 另外一个核通过标记来判断数据是否准备好。 这种操作存在标记位先写入问题。 数据可能还没有准备好。可能是没有计算完成， 也可能是数据没有从处理器缓存刷新到主存中。\n\n## JAVA内存模型\n\n屏蔽硬件和操作系统内存访问的差异， 在各种平台下达到一致的并发效果。JMM（Java Memory Model）是**一种规范，规范了虚拟机与计算机内存是怎么工作的。一个线程如何，何时能看到其它线程修改过的共享变量的值。以及必须时如何同步的访问共享变量。**\n\n堆（Heap）： 运行时数据区， 运行时动态分配内存， 存取速度相对慢一些。\n栈（Stack）： 存取速度比堆要快。仅次于寄存器。数据可以共享， 但是存在栈中的数据大小和生存期必须是确定的。缺乏灵活性。主要存放基本类型的变量和对象句柄。\n\n**当一个线程可以访问一个对象的时候， 它也可以访问该对象的成员变量。 如果两个线程同时调用同一个对象上的同一个方法， 它们将会都访问该对象的成员变量， 但是每个线程都拥有了该成员变量的私有拷贝。**\n\n![JMM](JMM.png)\n\nJMM主内存就是硬件的内存，本地内存是cpu的寄存器和高速缓存的一个抽象描述。JVM的内存模型只是对物理内存的划分， 只存在内存中。\n\n### 同步八种操作\n\n![JMM_8_Op](JMM_caozuo.png)\n\n1. lock: 作用于主内存变量， 把一个变量标识为一条线程独占状态 \n2. unlock： 作用于主内存变量， 把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定\n3. read： 作用于主内存的变量， 把一个变量从主内存传输到线程的工作内存中， 以便随后的load动作使用 \n4. load： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的变量副本中\n5. use： 作用于工作内存的变量， 把工作内存的一个变量值传递给执行引擎\n6. assign： 作用于工作内存的变量， 它把一个从执行引擎接收到的值赋值给工作内存的变量\n7. store： 作用于工作内存的变量， 把工作内存的一个变量的值传送到主内存中， 以便随后的write操作\n8. write： 作用于主内存的变量， 它把store操作从工作内存中得到的变量值放入主内存变量\n\n### 同步规则 \n1. 不允许read和load、store和write操作之一单独出现\n2. 把变量从主内存复制到工作内存， 就需要按顺序地执行read和load操作， 如果把变量从工作内存同步到主内存中， 就需要按顺序地执行store和write操作。 java内存模型只要求上述操作按顺序执行， 而没有保证必须是连续执行。\n3. 不允许一个线程丢弃它最近的assign操作， 即变量在工作内存中改变之后必须同步到主内存中\n4. 不允许一个线程没原因（没有发生任何assign操作）把数据同步回主内存中\n5. 一个新的变量只能在主内存诞生， 不允许工作内存中直接使用一个未被初始化（load或assign）的变量。也就是对一个变量实施use和store操作前， 必须先执行assign和load操作\n6. 一个变量同一时刻只允许一条线程对其lock操作， lock可以被同一条线程重复执行多次， lock和unlock必须成对出现\n7. 对一个变量的lock操作， 将会清空工作内存中此变量的值， 在执行引擎使用这个变量前需要重新执行load或者assign操作初始化这个变量的值\n8. 如果一个变量事先没有被lock操作锁定， 则不允许对它执行unlock操作， 也不允许去unlock一个被其他线程锁定的变量\n9. 对一个变量执行unlcok操作前， 必须先把变量同步到主内存中（执行store和write操作）\n\n## 并发的优势和风险\n\n![ad_disad](ad_disad.png)\n\n多线程环境下必须使用同步机制， 这导致很多编译器做的优化被抑制。\n\n测试不同主机上实现\n\n\n\n\n","source":"_posts/并发基本概念.md","raw":"---\ntitle: 并发基本概念\ndate: 2018-08-29 15:59:58\ntags:\n---\n\n## 基本概念\n\n并发： 同时拥有两个或者多个线程， 如果程序在单核处理器上运行， 多个线程将交替地换入或者换出内存， 这些线程是同时“存在”的，每个线程处于执行过程中的某个状态， 如果运行在多核处理器上， 此时每个线程都能分配到一个处理器核上， 因此可以同时运行。\n\n高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一， 它通常是指， 通过设计保证系统能够**同时并行处理**很多请求。\n\n\n## CPU多级缓存\n\nCPU频率太快， 主存跟不上， 这样在处理器时钟周期内， CPU常常需要等待主存， 浪费资源。 cache出现， 是为了缓解CPU和主存之间速度不匹配 **（速度 cpu > cache > memory）**.\n\n### 缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：\n\t\n\t* 时间局部性： 如果某个数据被访问， 那么不久将来也会被访问\n\t* 空间局部性： 如果某个数据被访问， 那么与它相邻的数据很快会被访问\n\n### cpu多级缓存 - 缓存一致性（MESI协议）\n\nMESI协议为了保证多个CPU cache之间缓存共享数据的一致性， 缓存控制器监听本地和远程操作的时候需要对地址一定的cache line状态做出修改。\n\n![MESI Protocal](MESI_protocal.jpg)\n\n#### 四个状态\n\n1. Modified: 该缓存行只被缓存在该CPU的缓存中，并且是被修改过（dirty），与主存的数据不一致。在允许其它CPU读取主存中相应内存之前需要写回（write back）主存。 写回后该缓存行状态变为独享（exclusive）状态。\n2. Exclusive：该缓存行只被缓存在该CPU的缓存中， 未被修改。 和主存数据一致。任何时候在其它CPU读取内存时变为共享状态（shared）。\n3. Shared：该缓存行被多个CPU缓存，各个缓存中数据与主存一致， 当一个CPU修改该缓存行， 其它CPU中该缓存行可以被作废（Invalid）\n4. Invalid：该缓存是无效的。\n\n#### 四种操作\n\n1. Local read: 读本地缓存中的数据 \n2. Local write: 数据写入本地缓存\n3. Remote read: 读取主存中的数据\n4. Remote write: 数据写回主存\n\n### 乱序执行优化\n\n处理器为提高运算速度而做出违背代码原有顺序的优化。 举个例子：\n一个核上执行数据准备操作，最后写一个标记表示准备就绪。 另外一个核通过标记来判断数据是否准备好。 这种操作存在标记位先写入问题。 数据可能还没有准备好。可能是没有计算完成， 也可能是数据没有从处理器缓存刷新到主存中。\n\n## JAVA内存模型\n\n屏蔽硬件和操作系统内存访问的差异， 在各种平台下达到一致的并发效果。JMM（Java Memory Model）是**一种规范，规范了虚拟机与计算机内存是怎么工作的。一个线程如何，何时能看到其它线程修改过的共享变量的值。以及必须时如何同步的访问共享变量。**\n\n堆（Heap）： 运行时数据区， 运行时动态分配内存， 存取速度相对慢一些。\n栈（Stack）： 存取速度比堆要快。仅次于寄存器。数据可以共享， 但是存在栈中的数据大小和生存期必须是确定的。缺乏灵活性。主要存放基本类型的变量和对象句柄。\n\n**当一个线程可以访问一个对象的时候， 它也可以访问该对象的成员变量。 如果两个线程同时调用同一个对象上的同一个方法， 它们将会都访问该对象的成员变量， 但是每个线程都拥有了该成员变量的私有拷贝。**\n\n![JMM](JMM.png)\n\nJMM主内存就是硬件的内存，本地内存是cpu的寄存器和高速缓存的一个抽象描述。JVM的内存模型只是对物理内存的划分， 只存在内存中。\n\n### 同步八种操作\n\n![JMM_8_Op](JMM_caozuo.png)\n\n1. lock: 作用于主内存变量， 把一个变量标识为一条线程独占状态 \n2. unlock： 作用于主内存变量， 把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定\n3. read： 作用于主内存的变量， 把一个变量从主内存传输到线程的工作内存中， 以便随后的load动作使用 \n4. load： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的变量副本中\n5. use： 作用于工作内存的变量， 把工作内存的一个变量值传递给执行引擎\n6. assign： 作用于工作内存的变量， 它把一个从执行引擎接收到的值赋值给工作内存的变量\n7. store： 作用于工作内存的变量， 把工作内存的一个变量的值传送到主内存中， 以便随后的write操作\n8. write： 作用于主内存的变量， 它把store操作从工作内存中得到的变量值放入主内存变量\n\n### 同步规则 \n1. 不允许read和load、store和write操作之一单独出现\n2. 把变量从主内存复制到工作内存， 就需要按顺序地执行read和load操作， 如果把变量从工作内存同步到主内存中， 就需要按顺序地执行store和write操作。 java内存模型只要求上述操作按顺序执行， 而没有保证必须是连续执行。\n3. 不允许一个线程丢弃它最近的assign操作， 即变量在工作内存中改变之后必须同步到主内存中\n4. 不允许一个线程没原因（没有发生任何assign操作）把数据同步回主内存中\n5. 一个新的变量只能在主内存诞生， 不允许工作内存中直接使用一个未被初始化（load或assign）的变量。也就是对一个变量实施use和store操作前， 必须先执行assign和load操作\n6. 一个变量同一时刻只允许一条线程对其lock操作， lock可以被同一条线程重复执行多次， lock和unlock必须成对出现\n7. 对一个变量的lock操作， 将会清空工作内存中此变量的值， 在执行引擎使用这个变量前需要重新执行load或者assign操作初始化这个变量的值\n8. 如果一个变量事先没有被lock操作锁定， 则不允许对它执行unlock操作， 也不允许去unlock一个被其他线程锁定的变量\n9. 对一个变量执行unlcok操作前， 必须先把变量同步到主内存中（执行store和write操作）\n\n## 并发的优势和风险\n\n![ad_disad](ad_disad.png)\n\n多线程环境下必须使用同步机制， 这导致很多编译器做的优化被抑制。\n\n测试不同主机上实现\n\n\n\n\n","slug":"并发基本概念","published":1,"updated":"2018-08-30T09:06:16.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l0340002hcr05bg4cre0","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>并发： 同时拥有两个或者多个线程， 如果程序在单核处理器上运行， 多个线程将交替地换入或者换出内存， 这些线程是同时“存在”的，每个线程处于执行过程中的某个状态， 如果运行在多核处理器上， 此时每个线程都能分配到一个处理器核上， 因此可以同时运行。</p>\n<p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一， 它通常是指， 通过设计保证系统能够<strong>同时并行处理</strong>很多请求。</p>\n<h2 id=\"CPU多级缓存\"><a href=\"#CPU多级缓存\" class=\"headerlink\" title=\"CPU多级缓存\"></a>CPU多级缓存</h2><p>CPU频率太快， 主存跟不上， 这样在处理器时钟周期内， CPU常常需要等待主存， 浪费资源。 cache出现， 是为了缓解CPU和主存之间速度不匹配 <strong>（速度 cpu &gt; cache &gt; memory）</strong>.</p>\n<h3 id=\"缓存的意义（就算cache远远小于主存，-CPU访问经常不命中）：\"><a href=\"#缓存的意义（就算cache远远小于主存，-CPU访问经常不命中）：\" class=\"headerlink\" title=\"缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：\"></a>缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：</h3><pre><code>* 时间局部性： 如果某个数据被访问， 那么不久将来也会被访问\n* 空间局部性： 如果某个数据被访问， 那么与它相邻的数据很快会被访问\n</code></pre><h3 id=\"cpu多级缓存-缓存一致性（MESI协议）\"><a href=\"#cpu多级缓存-缓存一致性（MESI协议）\" class=\"headerlink\" title=\"cpu多级缓存 - 缓存一致性（MESI协议）\"></a>cpu多级缓存 - 缓存一致性（MESI协议）</h3><p>MESI协议为了保证多个CPU cache之间缓存共享数据的一致性， 缓存控制器监听本地和远程操作的时候需要对地址一定的cache line状态做出修改。</p>\n<p><img src=\"MESI_protocal.jpg\" alt=\"MESI Protocal\"></p>\n<h4 id=\"四个状态\"><a href=\"#四个状态\" class=\"headerlink\" title=\"四个状态\"></a>四个状态</h4><ol>\n<li>Modified: 该缓存行只被缓存在该CPU的缓存中，并且是被修改过（dirty），与主存的数据不一致。在允许其它CPU读取主存中相应内存之前需要写回（write back）主存。 写回后该缓存行状态变为独享（exclusive）状态。</li>\n<li>Exclusive：该缓存行只被缓存在该CPU的缓存中， 未被修改。 和主存数据一致。任何时候在其它CPU读取内存时变为共享状态（shared）。</li>\n<li>Shared：该缓存行被多个CPU缓存，各个缓存中数据与主存一致， 当一个CPU修改该缓存行， 其它CPU中该缓存行可以被作废（Invalid）</li>\n<li>Invalid：该缓存是无效的。</li>\n</ol>\n<h4 id=\"四种操作\"><a href=\"#四种操作\" class=\"headerlink\" title=\"四种操作\"></a>四种操作</h4><ol>\n<li>Local read: 读本地缓存中的数据 </li>\n<li>Local write: 数据写入本地缓存</li>\n<li>Remote read: 读取主存中的数据</li>\n<li>Remote write: 数据写回主存</li>\n</ol>\n<h3 id=\"乱序执行优化\"><a href=\"#乱序执行优化\" class=\"headerlink\" title=\"乱序执行优化\"></a>乱序执行优化</h3><p>处理器为提高运算速度而做出违背代码原有顺序的优化。 举个例子：<br>一个核上执行数据准备操作，最后写一个标记表示准备就绪。 另外一个核通过标记来判断数据是否准备好。 这种操作存在标记位先写入问题。 数据可能还没有准备好。可能是没有计算完成， 也可能是数据没有从处理器缓存刷新到主存中。</p>\n<h2 id=\"JAVA内存模型\"><a href=\"#JAVA内存模型\" class=\"headerlink\" title=\"JAVA内存模型\"></a>JAVA内存模型</h2><p>屏蔽硬件和操作系统内存访问的差异， 在各种平台下达到一致的并发效果。JMM（Java Memory Model）是<strong>一种规范，规范了虚拟机与计算机内存是怎么工作的。一个线程如何，何时能看到其它线程修改过的共享变量的值。以及必须时如何同步的访问共享变量。</strong></p>\n<p>堆（Heap）： 运行时数据区， 运行时动态分配内存， 存取速度相对慢一些。<br>栈（Stack）： 存取速度比堆要快。仅次于寄存器。数据可以共享， 但是存在栈中的数据大小和生存期必须是确定的。缺乏灵活性。主要存放基本类型的变量和对象句柄。</p>\n<p><strong>当一个线程可以访问一个对象的时候， 它也可以访问该对象的成员变量。 如果两个线程同时调用同一个对象上的同一个方法， 它们将会都访问该对象的成员变量， 但是每个线程都拥有了该成员变量的私有拷贝。</strong></p>\n<p><img src=\"JMM.png\" alt=\"JMM\"></p>\n<p>JMM主内存就是硬件的内存，本地内存是cpu的寄存器和高速缓存的一个抽象描述。JVM的内存模型只是对物理内存的划分， 只存在内存中。</p>\n<h3 id=\"同步八种操作\"><a href=\"#同步八种操作\" class=\"headerlink\" title=\"同步八种操作\"></a>同步八种操作</h3><p><img src=\"JMM_caozuo.png\" alt=\"JMM_8_Op\"></p>\n<ol>\n<li>lock: 作用于主内存变量， 把一个变量标识为一条线程独占状态 </li>\n<li>unlock： 作用于主内存变量， 把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定</li>\n<li>read： 作用于主内存的变量， 把一个变量从主内存传输到线程的工作内存中， 以便随后的load动作使用 </li>\n<li>load： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>\n<li>use： 作用于工作内存的变量， 把工作内存的一个变量值传递给执行引擎</li>\n<li>assign： 作用于工作内存的变量， 它把一个从执行引擎接收到的值赋值给工作内存的变量</li>\n<li>store： 作用于工作内存的变量， 把工作内存的一个变量的值传送到主内存中， 以便随后的write操作</li>\n<li>write： 作用于主内存的变量， 它把store操作从工作内存中得到的变量值放入主内存变量</li>\n</ol>\n<h3 id=\"同步规则\"><a href=\"#同步规则\" class=\"headerlink\" title=\"同步规则\"></a>同步规则</h3><ol>\n<li>不允许read和load、store和write操作之一单独出现</li>\n<li>把变量从主内存复制到工作内存， 就需要按顺序地执行read和load操作， 如果把变量从工作内存同步到主内存中， 就需要按顺序地执行store和write操作。 java内存模型只要求上述操作按顺序执行， 而没有保证必须是连续执行。</li>\n<li>不允许一个线程丢弃它最近的assign操作， 即变量在工作内存中改变之后必须同步到主内存中</li>\n<li>不允许一个线程没原因（没有发生任何assign操作）把数据同步回主内存中</li>\n<li>一个新的变量只能在主内存诞生， 不允许工作内存中直接使用一个未被初始化（load或assign）的变量。也就是对一个变量实施use和store操作前， 必须先执行assign和load操作</li>\n<li>一个变量同一时刻只允许一条线程对其lock操作， lock可以被同一条线程重复执行多次， lock和unlock必须成对出现</li>\n<li>对一个变量的lock操作， 将会清空工作内存中此变量的值， 在执行引擎使用这个变量前需要重新执行load或者assign操作初始化这个变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定， 则不允许对它执行unlock操作， 也不允许去unlock一个被其他线程锁定的变量</li>\n<li>对一个变量执行unlcok操作前， 必须先把变量同步到主内存中（执行store和write操作）</li>\n</ol>\n<h2 id=\"并发的优势和风险\"><a href=\"#并发的优势和风险\" class=\"headerlink\" title=\"并发的优势和风险\"></a>并发的优势和风险</h2><p><img src=\"ad_disad.png\" alt=\"ad_disad\"></p>\n<p>多线程环境下必须使用同步机制， 这导致很多编译器做的优化被抑制。</p>\n<p>测试不同主机上实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>并发： 同时拥有两个或者多个线程， 如果程序在单核处理器上运行， 多个线程将交替地换入或者换出内存， 这些线程是同时“存在”的，每个线程处于执行过程中的某个状态， 如果运行在多核处理器上， 此时每个线程都能分配到一个处理器核上， 因此可以同时运行。</p>\n<p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一， 它通常是指， 通过设计保证系统能够<strong>同时并行处理</strong>很多请求。</p>\n<h2 id=\"CPU多级缓存\"><a href=\"#CPU多级缓存\" class=\"headerlink\" title=\"CPU多级缓存\"></a>CPU多级缓存</h2><p>CPU频率太快， 主存跟不上， 这样在处理器时钟周期内， CPU常常需要等待主存， 浪费资源。 cache出现， 是为了缓解CPU和主存之间速度不匹配 <strong>（速度 cpu &gt; cache &gt; memory）</strong>.</p>\n<h3 id=\"缓存的意义（就算cache远远小于主存，-CPU访问经常不命中）：\"><a href=\"#缓存的意义（就算cache远远小于主存，-CPU访问经常不命中）：\" class=\"headerlink\" title=\"缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：\"></a>缓存的意义（就算cache远远小于主存， CPU访问经常不命中）：</h3><pre><code>* 时间局部性： 如果某个数据被访问， 那么不久将来也会被访问\n* 空间局部性： 如果某个数据被访问， 那么与它相邻的数据很快会被访问\n</code></pre><h3 id=\"cpu多级缓存-缓存一致性（MESI协议）\"><a href=\"#cpu多级缓存-缓存一致性（MESI协议）\" class=\"headerlink\" title=\"cpu多级缓存 - 缓存一致性（MESI协议）\"></a>cpu多级缓存 - 缓存一致性（MESI协议）</h3><p>MESI协议为了保证多个CPU cache之间缓存共享数据的一致性， 缓存控制器监听本地和远程操作的时候需要对地址一定的cache line状态做出修改。</p>\n<p><img src=\"MESI_protocal.jpg\" alt=\"MESI Protocal\"></p>\n<h4 id=\"四个状态\"><a href=\"#四个状态\" class=\"headerlink\" title=\"四个状态\"></a>四个状态</h4><ol>\n<li>Modified: 该缓存行只被缓存在该CPU的缓存中，并且是被修改过（dirty），与主存的数据不一致。在允许其它CPU读取主存中相应内存之前需要写回（write back）主存。 写回后该缓存行状态变为独享（exclusive）状态。</li>\n<li>Exclusive：该缓存行只被缓存在该CPU的缓存中， 未被修改。 和主存数据一致。任何时候在其它CPU读取内存时变为共享状态（shared）。</li>\n<li>Shared：该缓存行被多个CPU缓存，各个缓存中数据与主存一致， 当一个CPU修改该缓存行， 其它CPU中该缓存行可以被作废（Invalid）</li>\n<li>Invalid：该缓存是无效的。</li>\n</ol>\n<h4 id=\"四种操作\"><a href=\"#四种操作\" class=\"headerlink\" title=\"四种操作\"></a>四种操作</h4><ol>\n<li>Local read: 读本地缓存中的数据 </li>\n<li>Local write: 数据写入本地缓存</li>\n<li>Remote read: 读取主存中的数据</li>\n<li>Remote write: 数据写回主存</li>\n</ol>\n<h3 id=\"乱序执行优化\"><a href=\"#乱序执行优化\" class=\"headerlink\" title=\"乱序执行优化\"></a>乱序执行优化</h3><p>处理器为提高运算速度而做出违背代码原有顺序的优化。 举个例子：<br>一个核上执行数据准备操作，最后写一个标记表示准备就绪。 另外一个核通过标记来判断数据是否准备好。 这种操作存在标记位先写入问题。 数据可能还没有准备好。可能是没有计算完成， 也可能是数据没有从处理器缓存刷新到主存中。</p>\n<h2 id=\"JAVA内存模型\"><a href=\"#JAVA内存模型\" class=\"headerlink\" title=\"JAVA内存模型\"></a>JAVA内存模型</h2><p>屏蔽硬件和操作系统内存访问的差异， 在各种平台下达到一致的并发效果。JMM（Java Memory Model）是<strong>一种规范，规范了虚拟机与计算机内存是怎么工作的。一个线程如何，何时能看到其它线程修改过的共享变量的值。以及必须时如何同步的访问共享变量。</strong></p>\n<p>堆（Heap）： 运行时数据区， 运行时动态分配内存， 存取速度相对慢一些。<br>栈（Stack）： 存取速度比堆要快。仅次于寄存器。数据可以共享， 但是存在栈中的数据大小和生存期必须是确定的。缺乏灵活性。主要存放基本类型的变量和对象句柄。</p>\n<p><strong>当一个线程可以访问一个对象的时候， 它也可以访问该对象的成员变量。 如果两个线程同时调用同一个对象上的同一个方法， 它们将会都访问该对象的成员变量， 但是每个线程都拥有了该成员变量的私有拷贝。</strong></p>\n<p><img src=\"JMM.png\" alt=\"JMM\"></p>\n<p>JMM主内存就是硬件的内存，本地内存是cpu的寄存器和高速缓存的一个抽象描述。JVM的内存模型只是对物理内存的划分， 只存在内存中。</p>\n<h3 id=\"同步八种操作\"><a href=\"#同步八种操作\" class=\"headerlink\" title=\"同步八种操作\"></a>同步八种操作</h3><p><img src=\"JMM_caozuo.png\" alt=\"JMM_8_Op\"></p>\n<ol>\n<li>lock: 作用于主内存变量， 把一个变量标识为一条线程独占状态 </li>\n<li>unlock： 作用于主内存变量， 把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定</li>\n<li>read： 作用于主内存的变量， 把一个变量从主内存传输到线程的工作内存中， 以便随后的load动作使用 </li>\n<li>load： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>\n<li>use： 作用于工作内存的变量， 把工作内存的一个变量值传递给执行引擎</li>\n<li>assign： 作用于工作内存的变量， 它把一个从执行引擎接收到的值赋值给工作内存的变量</li>\n<li>store： 作用于工作内存的变量， 把工作内存的一个变量的值传送到主内存中， 以便随后的write操作</li>\n<li>write： 作用于主内存的变量， 它把store操作从工作内存中得到的变量值放入主内存变量</li>\n</ol>\n<h3 id=\"同步规则\"><a href=\"#同步规则\" class=\"headerlink\" title=\"同步规则\"></a>同步规则</h3><ol>\n<li>不允许read和load、store和write操作之一单独出现</li>\n<li>把变量从主内存复制到工作内存， 就需要按顺序地执行read和load操作， 如果把变量从工作内存同步到主内存中， 就需要按顺序地执行store和write操作。 java内存模型只要求上述操作按顺序执行， 而没有保证必须是连续执行。</li>\n<li>不允许一个线程丢弃它最近的assign操作， 即变量在工作内存中改变之后必须同步到主内存中</li>\n<li>不允许一个线程没原因（没有发生任何assign操作）把数据同步回主内存中</li>\n<li>一个新的变量只能在主内存诞生， 不允许工作内存中直接使用一个未被初始化（load或assign）的变量。也就是对一个变量实施use和store操作前， 必须先执行assign和load操作</li>\n<li>一个变量同一时刻只允许一条线程对其lock操作， lock可以被同一条线程重复执行多次， lock和unlock必须成对出现</li>\n<li>对一个变量的lock操作， 将会清空工作内存中此变量的值， 在执行引擎使用这个变量前需要重新执行load或者assign操作初始化这个变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定， 则不允许对它执行unlock操作， 也不允许去unlock一个被其他线程锁定的变量</li>\n<li>对一个变量执行unlcok操作前， 必须先把变量同步到主内存中（执行store和write操作）</li>\n</ol>\n<h2 id=\"并发的优势和风险\"><a href=\"#并发的优势和风险\" class=\"headerlink\" title=\"并发的优势和风险\"></a>并发的优势和风险</h2><p><img src=\"ad_disad.png\" alt=\"ad_disad\"></p>\n<p>多线程环境下必须使用同步机制， 这导致很多编译器做的优化被抑制。</p>\n<p>测试不同主机上实现</p>\n"},{"title":"线程安全性-原子性","date":"2018-08-31T03:26:59.000Z","_content":"\n# 线程安全性定义\n\n当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。\n\n线程安全性主要体现在3个方面：\n1. 原子性\n2. 可见性\n3. 有序性\n\n# 原子性实现-Atomic包\n\n## AtomicXXX, CAS \n\n比如AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）需要比较，只有一样才累加。  并发环境下CAS失败率高， 一个线程的原子操作可能循环多次尝试，影响性能。  \t\n\n\n## AtomicLong, LongAdder\n\nJDK8新增了LongAdder, 和AtomicLong有相似点。 LongAdder有优点，把热点数据分离， 把AtomicLong内部核心数据value被分为一个数组（多个cell）。 每个线程访问时候根据哈希等方法映射到一个节点进行计数。 最终结果为各个节点数据求和累加。 LongAdder等于把AtomicLong单点的更新压力分散到多个节点上。 低并发环境下通过对base的直接更新可以保证和AtomicLong效率基本相同。\n缺点是统计时候如果有并发更新统计数据可能会有误差。 如果要生成全局唯一的序列号就不适合用LongAdder。\n\n## AtomicReference, AtomicReferenceFieldUpdater\n\n\tpublic class AtomicReferenceExample {\n    \tprivate static AtomicReference<Integer> count = new AtomicReference(0);\n    \tpublic static void main(String[] args) {\n        \tcount.compareAndSet(0, 2);\n        \tcount.compareAndSet(2, 4);\n        \tlog.info(\"count: {}\", count.get());\n    \t}\n\t}\n\n\n\tpublic class AtomicFieldUpdaterExample {\n    \tprivate static AtomicIntegerFieldUpdater<AtomicFieldUpdaterExample> updater =\n            AtomicIntegerFieldUpdater.newUpdater(AtomicFieldUpdaterExample.class, \"count\");\n    \t@Getter\n    \tpublic volatile int count = 100;\n\n    \tpublic static void main(String[] args) {\n        \tAtomicFieldUpdaterExample example = new AtomicFieldUpdaterExample();\n        \tif(updater.compareAndSet(example, 100, 120)) {\n            \tlog.info(\"update success 1, {}\", example.getCount());\n        \t}\n        \tif(updater.compareAndSet(example, 100, 120)){\n            \tlog.info(\"update success 2, {}\", example.getCount());\n        \t} else {\n            \tlog.info(\"update fail, {}\", example.getCount());\n        \t}\n    \t}\n\t}\n\t只能更新非static的volatile变量\n\n\n## AtomicStampReference: CAS的ABA问题\n\n一个线程把变量A变为B又变回A， 这时候需要维护一个变化的Stamp来反映变量确实变化过。\n\n# 原子性 - 锁\n\n## synchronized:依赖JVM的同步锁\n\n修饰代码块： 作用于调用的对象\n修饰方法： 作用于调用的对象\n修饰静态方法： 作用于所有对象\n修饰类： 作用于所有对象\n\n## Lock\n依赖特殊的CPU指令， 代码实现， Reentrantlock\n\n# 原子性 - 对比\n\n* Synchronized: 不可中断锁， 适合竞争不激烈， 可读性好\n* Lock: 可中断锁（unlock）， 多样化同步， 竞争激烈时能维持常态\n* Atomic： 竞争激烈时能维持常态， 比lock性能好， 只能同步一个值\n\n","source":"_posts/线程安全性-原子性.md","raw":"---\ntitle: 线程安全性-原子性\ndate: 2018-08-31 11:26:59\ntags:\n---\n\n# 线程安全性定义\n\n当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。\n\n线程安全性主要体现在3个方面：\n1. 原子性\n2. 可见性\n3. 有序性\n\n# 原子性实现-Atomic包\n\n## AtomicXXX, CAS \n\n比如AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）需要比较，只有一样才累加。  并发环境下CAS失败率高， 一个线程的原子操作可能循环多次尝试，影响性能。  \t\n\n\n## AtomicLong, LongAdder\n\nJDK8新增了LongAdder, 和AtomicLong有相似点。 LongAdder有优点，把热点数据分离， 把AtomicLong内部核心数据value被分为一个数组（多个cell）。 每个线程访问时候根据哈希等方法映射到一个节点进行计数。 最终结果为各个节点数据求和累加。 LongAdder等于把AtomicLong单点的更新压力分散到多个节点上。 低并发环境下通过对base的直接更新可以保证和AtomicLong效率基本相同。\n缺点是统计时候如果有并发更新统计数据可能会有误差。 如果要生成全局唯一的序列号就不适合用LongAdder。\n\n## AtomicReference, AtomicReferenceFieldUpdater\n\n\tpublic class AtomicReferenceExample {\n    \tprivate static AtomicReference<Integer> count = new AtomicReference(0);\n    \tpublic static void main(String[] args) {\n        \tcount.compareAndSet(0, 2);\n        \tcount.compareAndSet(2, 4);\n        \tlog.info(\"count: {}\", count.get());\n    \t}\n\t}\n\n\n\tpublic class AtomicFieldUpdaterExample {\n    \tprivate static AtomicIntegerFieldUpdater<AtomicFieldUpdaterExample> updater =\n            AtomicIntegerFieldUpdater.newUpdater(AtomicFieldUpdaterExample.class, \"count\");\n    \t@Getter\n    \tpublic volatile int count = 100;\n\n    \tpublic static void main(String[] args) {\n        \tAtomicFieldUpdaterExample example = new AtomicFieldUpdaterExample();\n        \tif(updater.compareAndSet(example, 100, 120)) {\n            \tlog.info(\"update success 1, {}\", example.getCount());\n        \t}\n        \tif(updater.compareAndSet(example, 100, 120)){\n            \tlog.info(\"update success 2, {}\", example.getCount());\n        \t} else {\n            \tlog.info(\"update fail, {}\", example.getCount());\n        \t}\n    \t}\n\t}\n\t只能更新非static的volatile变量\n\n\n## AtomicStampReference: CAS的ABA问题\n\n一个线程把变量A变为B又变回A， 这时候需要维护一个变化的Stamp来反映变量确实变化过。\n\n# 原子性 - 锁\n\n## synchronized:依赖JVM的同步锁\n\n修饰代码块： 作用于调用的对象\n修饰方法： 作用于调用的对象\n修饰静态方法： 作用于所有对象\n修饰类： 作用于所有对象\n\n## Lock\n依赖特殊的CPU指令， 代码实现， Reentrantlock\n\n# 原子性 - 对比\n\n* Synchronized: 不可中断锁， 适合竞争不激烈， 可读性好\n* Lock: 可中断锁（unlock）， 多样化同步， 竞争激烈时能维持常态\n* Atomic： 竞争激烈时能维持常态， 比lock性能好， 只能同步一个值\n\n","slug":"线程安全性-原子性","published":1,"updated":"2018-09-03T05:52:30.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l0350003hcr0bq9x5v0c","content":"<h1 id=\"线程安全性定义\"><a href=\"#线程安全性定义\" class=\"headerlink\" title=\"线程安全性定义\"></a>线程安全性定义</h1><p>当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。</p>\n<p>线程安全性主要体现在3个方面：</p>\n<ol>\n<li>原子性</li>\n<li>可见性</li>\n<li>有序性</li>\n</ol>\n<h1 id=\"原子性实现-Atomic包\"><a href=\"#原子性实现-Atomic包\" class=\"headerlink\" title=\"原子性实现-Atomic包\"></a>原子性实现-Atomic包</h1><h2 id=\"AtomicXXX-CAS\"><a href=\"#AtomicXXX-CAS\" class=\"headerlink\" title=\"AtomicXXX, CAS\"></a>AtomicXXX, CAS</h2><p>比如AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）需要比较，只有一样才累加。  并发环境下CAS失败率高， 一个线程的原子操作可能循环多次尝试，影响性能。      </p>\n<h2 id=\"AtomicLong-LongAdder\"><a href=\"#AtomicLong-LongAdder\" class=\"headerlink\" title=\"AtomicLong, LongAdder\"></a>AtomicLong, LongAdder</h2><p>JDK8新增了LongAdder, 和AtomicLong有相似点。 LongAdder有优点，把热点数据分离， 把AtomicLong内部核心数据value被分为一个数组（多个cell）。 每个线程访问时候根据哈希等方法映射到一个节点进行计数。 最终结果为各个节点数据求和累加。 LongAdder等于把AtomicLong单点的更新压力分散到多个节点上。 低并发环境下通过对base的直接更新可以保证和AtomicLong效率基本相同。<br>缺点是统计时候如果有并发更新统计数据可能会有误差。 如果要生成全局唯一的序列号就不适合用LongAdder。</p>\n<h2 id=\"AtomicReference-AtomicReferenceFieldUpdater\"><a href=\"#AtomicReference-AtomicReferenceFieldUpdater\" class=\"headerlink\" title=\"AtomicReference, AtomicReferenceFieldUpdater\"></a>AtomicReference, AtomicReferenceFieldUpdater</h2><pre><code>public class AtomicReferenceExample {\n    private static AtomicReference&lt;Integer&gt; count = new AtomicReference(0);\n    public static void main(String[] args) {\n        count.compareAndSet(0, 2);\n        count.compareAndSet(2, 4);\n        log.info(&quot;count: {}&quot;, count.get());\n    }\n}\n\n\npublic class AtomicFieldUpdaterExample {\n    private static AtomicIntegerFieldUpdater&lt;AtomicFieldUpdaterExample&gt; updater =\n        AtomicIntegerFieldUpdater.newUpdater(AtomicFieldUpdaterExample.class, &quot;count&quot;);\n    @Getter\n    public volatile int count = 100;\n\n    public static void main(String[] args) {\n        AtomicFieldUpdaterExample example = new AtomicFieldUpdaterExample();\n        if(updater.compareAndSet(example, 100, 120)) {\n            log.info(&quot;update success 1, {}&quot;, example.getCount());\n        }\n        if(updater.compareAndSet(example, 100, 120)){\n            log.info(&quot;update success 2, {}&quot;, example.getCount());\n        } else {\n            log.info(&quot;update fail, {}&quot;, example.getCount());\n        }\n    }\n}\n只能更新非static的volatile变量\n</code></pre><h2 id=\"AtomicStampReference-CAS的ABA问题\"><a href=\"#AtomicStampReference-CAS的ABA问题\" class=\"headerlink\" title=\"AtomicStampReference: CAS的ABA问题\"></a>AtomicStampReference: CAS的ABA问题</h2><p>一个线程把变量A变为B又变回A， 这时候需要维护一个变化的Stamp来反映变量确实变化过。</p>\n<h1 id=\"原子性-锁\"><a href=\"#原子性-锁\" class=\"headerlink\" title=\"原子性 - 锁\"></a>原子性 - 锁</h1><h2 id=\"synchronized-依赖JVM的同步锁\"><a href=\"#synchronized-依赖JVM的同步锁\" class=\"headerlink\" title=\"synchronized:依赖JVM的同步锁\"></a>synchronized:依赖JVM的同步锁</h2><p>修饰代码块： 作用于调用的对象<br>修饰方法： 作用于调用的对象<br>修饰静态方法： 作用于所有对象<br>修饰类： 作用于所有对象</p>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>依赖特殊的CPU指令， 代码实现， Reentrantlock</p>\n<h1 id=\"原子性-对比\"><a href=\"#原子性-对比\" class=\"headerlink\" title=\"原子性 - 对比\"></a>原子性 - 对比</h1><ul>\n<li>Synchronized: 不可中断锁， 适合竞争不激烈， 可读性好</li>\n<li>Lock: 可中断锁（unlock）， 多样化同步， 竞争激烈时能维持常态</li>\n<li>Atomic： 竞争激烈时能维持常态， 比lock性能好， 只能同步一个值</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程安全性定义\"><a href=\"#线程安全性定义\" class=\"headerlink\" title=\"线程安全性定义\"></a>线程安全性定义</h1><p>当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。</p>\n<p>线程安全性主要体现在3个方面：</p>\n<ol>\n<li>原子性</li>\n<li>可见性</li>\n<li>有序性</li>\n</ol>\n<h1 id=\"原子性实现-Atomic包\"><a href=\"#原子性实现-Atomic包\" class=\"headerlink\" title=\"原子性实现-Atomic包\"></a>原子性实现-Atomic包</h1><h2 id=\"AtomicXXX-CAS\"><a href=\"#AtomicXXX-CAS\" class=\"headerlink\" title=\"AtomicXXX, CAS\"></a>AtomicXXX, CAS</h2><p>比如AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）需要比较，只有一样才累加。  并发环境下CAS失败率高， 一个线程的原子操作可能循环多次尝试，影响性能。      </p>\n<h2 id=\"AtomicLong-LongAdder\"><a href=\"#AtomicLong-LongAdder\" class=\"headerlink\" title=\"AtomicLong, LongAdder\"></a>AtomicLong, LongAdder</h2><p>JDK8新增了LongAdder, 和AtomicLong有相似点。 LongAdder有优点，把热点数据分离， 把AtomicLong内部核心数据value被分为一个数组（多个cell）。 每个线程访问时候根据哈希等方法映射到一个节点进行计数。 最终结果为各个节点数据求和累加。 LongAdder等于把AtomicLong单点的更新压力分散到多个节点上。 低并发环境下通过对base的直接更新可以保证和AtomicLong效率基本相同。<br>缺点是统计时候如果有并发更新统计数据可能会有误差。 如果要生成全局唯一的序列号就不适合用LongAdder。</p>\n<h2 id=\"AtomicReference-AtomicReferenceFieldUpdater\"><a href=\"#AtomicReference-AtomicReferenceFieldUpdater\" class=\"headerlink\" title=\"AtomicReference, AtomicReferenceFieldUpdater\"></a>AtomicReference, AtomicReferenceFieldUpdater</h2><pre><code>public class AtomicReferenceExample {\n    private static AtomicReference&lt;Integer&gt; count = new AtomicReference(0);\n    public static void main(String[] args) {\n        count.compareAndSet(0, 2);\n        count.compareAndSet(2, 4);\n        log.info(&quot;count: {}&quot;, count.get());\n    }\n}\n\n\npublic class AtomicFieldUpdaterExample {\n    private static AtomicIntegerFieldUpdater&lt;AtomicFieldUpdaterExample&gt; updater =\n        AtomicIntegerFieldUpdater.newUpdater(AtomicFieldUpdaterExample.class, &quot;count&quot;);\n    @Getter\n    public volatile int count = 100;\n\n    public static void main(String[] args) {\n        AtomicFieldUpdaterExample example = new AtomicFieldUpdaterExample();\n        if(updater.compareAndSet(example, 100, 120)) {\n            log.info(&quot;update success 1, {}&quot;, example.getCount());\n        }\n        if(updater.compareAndSet(example, 100, 120)){\n            log.info(&quot;update success 2, {}&quot;, example.getCount());\n        } else {\n            log.info(&quot;update fail, {}&quot;, example.getCount());\n        }\n    }\n}\n只能更新非static的volatile变量\n</code></pre><h2 id=\"AtomicStampReference-CAS的ABA问题\"><a href=\"#AtomicStampReference-CAS的ABA问题\" class=\"headerlink\" title=\"AtomicStampReference: CAS的ABA问题\"></a>AtomicStampReference: CAS的ABA问题</h2><p>一个线程把变量A变为B又变回A， 这时候需要维护一个变化的Stamp来反映变量确实变化过。</p>\n<h1 id=\"原子性-锁\"><a href=\"#原子性-锁\" class=\"headerlink\" title=\"原子性 - 锁\"></a>原子性 - 锁</h1><h2 id=\"synchronized-依赖JVM的同步锁\"><a href=\"#synchronized-依赖JVM的同步锁\" class=\"headerlink\" title=\"synchronized:依赖JVM的同步锁\"></a>synchronized:依赖JVM的同步锁</h2><p>修饰代码块： 作用于调用的对象<br>修饰方法： 作用于调用的对象<br>修饰静态方法： 作用于所有对象<br>修饰类： 作用于所有对象</p>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>依赖特殊的CPU指令， 代码实现， Reentrantlock</p>\n<h1 id=\"原子性-对比\"><a href=\"#原子性-对比\" class=\"headerlink\" title=\"原子性 - 对比\"></a>原子性 - 对比</h1><ul>\n<li>Synchronized: 不可中断锁， 适合竞争不激烈， 可读性好</li>\n<li>Lock: 可中断锁（unlock）， 多样化同步， 竞争激烈时能维持常态</li>\n<li>Atomic： 竞争激烈时能维持常态， 比lock性能好， 只能同步一个值</li>\n</ul>\n"},{"title":"简单并发场景模拟","date":"2018-08-30T13:43:30.000Z","_content":"\n## Postman\n\nHttp请求模拟工具， 也能模拟并发， 但是不是很专业\n\n## Apache Bench (AB)\n\nApache附带的工具， 测试网站性能， 简单好用， 没有强大的图形界面支持\n\n## JMeter\n\nApache开发的压力测试工具\n\n## 并发模拟代码\n\n模拟多线程并发累加count计数器变量。\n\n### Semaphore\n\n用到Semaphore信号量来模拟同时允许多少线程执行， 如果不能获取信号量， 线程就阻塞。 Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。 线程运行时首先获取许可permits, 如果成功， 书可数减1， 如果线程运行完释放许可， 许可数就加1. 许可数为0， 则获取失败。 \n\n### CountDownLatch\n\nCountDownLatch模拟计数器闭锁， 赋值为总的请求数， 每个请求执行完countdown一次。 await操作能被执行说明所有线程执行完。 一个典型的应用场景是启动一个服务时， 主线程需要等待多个组件加载完毕， 之后再继续执行。\n\n\n\n\tpublic class ConcurrencyTest {\n    \t// 请求总数\n    \tpublic static int clientTotal = 5000;\n    \t// 同时并发执行的线程数\n    \tpublic static int threadTotal = 200;\n\n    \tpublic static int count = 0;\n    \tpublic static void main(String[] args) throws InterruptedException {\n        \tExecutorService executorService = Executors.newCachedThreadPool();\n        \t// 信号量\n        \tfinal Semaphore semaphore = new Semaphore(threadTotal);\n        \t// 计数器闭锁\n        \tfinal CountDownLatch countDownLatch = new CountDownLatch(clientTotal);\n        \tfor(int i = 0; i < clientTotal; i++){\n            \texecutorService.execute(() -> {\n                \ttry {\n                    \t// 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞\n                    \tsemaphore.acquire();\n                    \tadd();\n                    \tsemaphore.release();\n                \t} catch (InterruptedException e) {\n                    \te.printStackTrace();\n                    \tlog.error(\"Exception\", e);\n                \t}\n                \t// 执行完一次， 计数值减一\n                \tcountDownLatch.countDown();\n            \t});\n        \t}\n        \t// 保证countdownLatch必须减为0， 这表明所有线程都执行完\n        \tcountDownLatch.await();\n        \texecutorService.shutdown();\n        \tlog.info(\"Count:{}\", count);\n    \t}\n    \tprivate static void add(){\n        \tcount++;\n    \t}\n\t}\n\n\n每次执行结果count值会变， 说明存在并发问题。\n\t\n\n","source":"_posts/并发模拟.md","raw":"---\ntitle: 简单并发场景模拟\ndate: 2018-08-30 21:43:30\ntags:\n---\n\n## Postman\n\nHttp请求模拟工具， 也能模拟并发， 但是不是很专业\n\n## Apache Bench (AB)\n\nApache附带的工具， 测试网站性能， 简单好用， 没有强大的图形界面支持\n\n## JMeter\n\nApache开发的压力测试工具\n\n## 并发模拟代码\n\n模拟多线程并发累加count计数器变量。\n\n### Semaphore\n\n用到Semaphore信号量来模拟同时允许多少线程执行， 如果不能获取信号量， 线程就阻塞。 Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。 线程运行时首先获取许可permits, 如果成功， 书可数减1， 如果线程运行完释放许可， 许可数就加1. 许可数为0， 则获取失败。 \n\n### CountDownLatch\n\nCountDownLatch模拟计数器闭锁， 赋值为总的请求数， 每个请求执行完countdown一次。 await操作能被执行说明所有线程执行完。 一个典型的应用场景是启动一个服务时， 主线程需要等待多个组件加载完毕， 之后再继续执行。\n\n\n\n\tpublic class ConcurrencyTest {\n    \t// 请求总数\n    \tpublic static int clientTotal = 5000;\n    \t// 同时并发执行的线程数\n    \tpublic static int threadTotal = 200;\n\n    \tpublic static int count = 0;\n    \tpublic static void main(String[] args) throws InterruptedException {\n        \tExecutorService executorService = Executors.newCachedThreadPool();\n        \t// 信号量\n        \tfinal Semaphore semaphore = new Semaphore(threadTotal);\n        \t// 计数器闭锁\n        \tfinal CountDownLatch countDownLatch = new CountDownLatch(clientTotal);\n        \tfor(int i = 0; i < clientTotal; i++){\n            \texecutorService.execute(() -> {\n                \ttry {\n                    \t// 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞\n                    \tsemaphore.acquire();\n                    \tadd();\n                    \tsemaphore.release();\n                \t} catch (InterruptedException e) {\n                    \te.printStackTrace();\n                    \tlog.error(\"Exception\", e);\n                \t}\n                \t// 执行完一次， 计数值减一\n                \tcountDownLatch.countDown();\n            \t});\n        \t}\n        \t// 保证countdownLatch必须减为0， 这表明所有线程都执行完\n        \tcountDownLatch.await();\n        \texecutorService.shutdown();\n        \tlog.info(\"Count:{}\", count);\n    \t}\n    \tprivate static void add(){\n        \tcount++;\n    \t}\n\t}\n\n\n每次执行结果count值会变， 说明存在并发问题。\n\t\n\n","slug":"并发模拟","published":1,"updated":"2018-08-31T05:48:08.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l0360004hcr0mbl75qj9","content":"<h2 id=\"Postman\"><a href=\"#Postman\" class=\"headerlink\" title=\"Postman\"></a>Postman</h2><p>Http请求模拟工具， 也能模拟并发， 但是不是很专业</p>\n<h2 id=\"Apache-Bench-AB\"><a href=\"#Apache-Bench-AB\" class=\"headerlink\" title=\"Apache Bench (AB)\"></a>Apache Bench (AB)</h2><p>Apache附带的工具， 测试网站性能， 简单好用， 没有强大的图形界面支持</p>\n<h2 id=\"JMeter\"><a href=\"#JMeter\" class=\"headerlink\" title=\"JMeter\"></a>JMeter</h2><p>Apache开发的压力测试工具</p>\n<h2 id=\"并发模拟代码\"><a href=\"#并发模拟代码\" class=\"headerlink\" title=\"并发模拟代码\"></a>并发模拟代码</h2><p>模拟多线程并发累加count计数器变量。</p>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>用到Semaphore信号量来模拟同时允许多少线程执行， 如果不能获取信号量， 线程就阻塞。 Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。 线程运行时首先获取许可permits, 如果成功， 书可数减1， 如果线程运行完释放许可， 许可数就加1. 许可数为0， 则获取失败。 </p>\n<h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>CountDownLatch模拟计数器闭锁， 赋值为总的请求数， 每个请求执行完countdown一次。 await操作能被执行说明所有线程执行完。 一个典型的应用场景是启动一个服务时， 主线程需要等待多个组件加载完毕， 之后再继续执行。</p>\n<pre><code>public class ConcurrencyTest {\n    // 请求总数\n    public static int clientTotal = 5000;\n    // 同时并发执行的线程数\n    public static int threadTotal = 200;\n\n    public static int count = 0;\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        // 信号量\n        final Semaphore semaphore = new Semaphore(threadTotal);\n        // 计数器闭锁\n        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);\n        for(int i = 0; i &lt; clientTotal; i++){\n            executorService.execute(() -&gt; {\n                try {\n                    // 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞\n                    semaphore.acquire();\n                    add();\n                    semaphore.release();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    log.error(&quot;Exception&quot;, e);\n                }\n                // 执行完一次， 计数值减一\n                countDownLatch.countDown();\n            });\n        }\n        // 保证countdownLatch必须减为0， 这表明所有线程都执行完\n        countDownLatch.await();\n        executorService.shutdown();\n        log.info(&quot;Count:{}&quot;, count);\n    }\n    private static void add(){\n        count++;\n    }\n}\n</code></pre><p>每次执行结果count值会变， 说明存在并发问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Postman\"><a href=\"#Postman\" class=\"headerlink\" title=\"Postman\"></a>Postman</h2><p>Http请求模拟工具， 也能模拟并发， 但是不是很专业</p>\n<h2 id=\"Apache-Bench-AB\"><a href=\"#Apache-Bench-AB\" class=\"headerlink\" title=\"Apache Bench (AB)\"></a>Apache Bench (AB)</h2><p>Apache附带的工具， 测试网站性能， 简单好用， 没有强大的图形界面支持</p>\n<h2 id=\"JMeter\"><a href=\"#JMeter\" class=\"headerlink\" title=\"JMeter\"></a>JMeter</h2><p>Apache开发的压力测试工具</p>\n<h2 id=\"并发模拟代码\"><a href=\"#并发模拟代码\" class=\"headerlink\" title=\"并发模拟代码\"></a>并发模拟代码</h2><p>模拟多线程并发累加count计数器变量。</p>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>用到Semaphore信号量来模拟同时允许多少线程执行， 如果不能获取信号量， 线程就阻塞。 Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。 线程运行时首先获取许可permits, 如果成功， 书可数减1， 如果线程运行完释放许可， 许可数就加1. 许可数为0， 则获取失败。 </p>\n<h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>CountDownLatch模拟计数器闭锁， 赋值为总的请求数， 每个请求执行完countdown一次。 await操作能被执行说明所有线程执行完。 一个典型的应用场景是启动一个服务时， 主线程需要等待多个组件加载完毕， 之后再继续执行。</p>\n<pre><code>public class ConcurrencyTest {\n    // 请求总数\n    public static int clientTotal = 5000;\n    // 同时并发执行的线程数\n    public static int threadTotal = 200;\n\n    public static int count = 0;\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        // 信号量\n        final Semaphore semaphore = new Semaphore(threadTotal);\n        // 计数器闭锁\n        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);\n        for(int i = 0; i &lt; clientTotal; i++){\n            executorService.execute(() -&gt; {\n                try {\n                    // 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞\n                    semaphore.acquire();\n                    add();\n                    semaphore.release();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    log.error(&quot;Exception&quot;, e);\n                }\n                // 执行完一次， 计数值减一\n                countDownLatch.countDown();\n            });\n        }\n        // 保证countdownLatch必须减为0， 这表明所有线程都执行完\n        countDownLatch.await();\n        executorService.shutdown();\n        log.info(&quot;Count:{}&quot;, count);\n    }\n    private static void add(){\n        count++;\n    }\n}\n</code></pre><p>每次执行结果count值会变， 说明存在并发问题。</p>\n"},{"title":"Hexo blog framework","date":"2018-08-20T09:00:41.000Z","_content":"\nI have been thinking for a while to create my own personal tech blog to record my tech studies. And I came accross Hexo, a simple blog framework for us to create our own blogs. It's super helpful for non front-end developers. Here are the steps you can follow.\n\n# Steps \n\n## Download node.js\nHere I use node-v5.6.0\n\n## Install Hexo and packages\nScreen Shot 2018-08-20 at 5.34.24 PM\n\t$ npm install -g hexo\n\t$ hexo init\n\t$ npm install\n\nYou will be able to view the default blog page (localhost:4000) generated by hexo locally after type in,\n    \n    $ hexo g \n    $ hexo s\n\n## Deploy code to github\n\nYou need to create a github repository following the naming pattern: \"yourname.github.io\", then edit the config.yml file in the root path.\n\n![github_config](github_config.png)\n\nDownload the hexo-deployer-git plugin.\n\n\t$ npm install hexo-deployer-git --save\n\nAfter set up the ssh keys, you should be able to deploy code to github. \n\n\t$ hexo g\n\t$ hexo d\n\nThen, you can view the blog page from github using the url: yourname.github.io\n\n\n## Add themes to your blog\n\nDownload a theme for your blog is easy, you can do it like this:\n\n\t$ git clone https://github.com/wuchong/jacman.git themes/jacman\n\nAfter you execute this command, a theme \"jacman\" will be intalled to the \"themes\" folder, and what you need to do is adding to config_yml file, replace the default theme \"landscape\".\n\nMore themes would be available in [Hexo](https://hexo.io/themes/).\n\n## Add new blog\n\nAt this point, creat a new blog is simply by typing the command\n\n\t$ hexo new\n\n\t\n","source":"_posts/Hexo-blog-framework.md","raw":"---\ntitle: Hexo blog framework\ndate: 2018-08-20 17:00:41\ntags:\n---\n\nI have been thinking for a while to create my own personal tech blog to record my tech studies. And I came accross Hexo, a simple blog framework for us to create our own blogs. It's super helpful for non front-end developers. Here are the steps you can follow.\n\n# Steps \n\n## Download node.js\nHere I use node-v5.6.0\n\n## Install Hexo and packages\nScreen Shot 2018-08-20 at 5.34.24 PM\n\t$ npm install -g hexo\n\t$ hexo init\n\t$ npm install\n\nYou will be able to view the default blog page (localhost:4000) generated by hexo locally after type in,\n    \n    $ hexo g \n    $ hexo s\n\n## Deploy code to github\n\nYou need to create a github repository following the naming pattern: \"yourname.github.io\", then edit the config.yml file in the root path.\n\n![github_config](github_config.png)\n\nDownload the hexo-deployer-git plugin.\n\n\t$ npm install hexo-deployer-git --save\n\nAfter set up the ssh keys, you should be able to deploy code to github. \n\n\t$ hexo g\n\t$ hexo d\n\nThen, you can view the blog page from github using the url: yourname.github.io\n\n\n## Add themes to your blog\n\nDownload a theme for your blog is easy, you can do it like this:\n\n\t$ git clone https://github.com/wuchong/jacman.git themes/jacman\n\nAfter you execute this command, a theme \"jacman\" will be intalled to the \"themes\" folder, and what you need to do is adding to config_yml file, replace the default theme \"landscape\".\n\nMore themes would be available in [Hexo](https://hexo.io/themes/).\n\n## Add new blog\n\nAt this point, creat a new blog is simply by typing the command\n\n\t$ hexo new\n\n\t\n","slug":"Hexo-blog-framework","published":1,"updated":"2018-09-03T05:52:30.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l0370005hcr0kveji83l","content":"<p>I have been thinking for a while to create my own personal tech blog to record my tech studies. And I came accross Hexo, a simple blog framework for us to create our own blogs. It’s super helpful for non front-end developers. Here are the steps you can follow.</p>\n<h1 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps\"></a>Steps</h1><h2 id=\"Download-node-js\"><a href=\"#Download-node-js\" class=\"headerlink\" title=\"Download node.js\"></a>Download node.js</h2><p>Here I use node-v5.6.0</p>\n<h2 id=\"Install-Hexo-and-packages\"><a href=\"#Install-Hexo-and-packages\" class=\"headerlink\" title=\"Install Hexo and packages\"></a>Install Hexo and packages</h2><p>Screen Shot 2018-08-20 at 5.34.24 PM<br>    $ npm install -g hexo<br>    $ hexo init<br>    $ npm install</p>\n<p>You will be able to view the default blog page (localhost:4000) generated by hexo locally after type in,</p>\n<pre><code>$ hexo g \n$ hexo s\n</code></pre><h2 id=\"Deploy-code-to-github\"><a href=\"#Deploy-code-to-github\" class=\"headerlink\" title=\"Deploy code to github\"></a>Deploy code to github</h2><p>You need to create a github repository following the naming pattern: “yourname.github.io”, then edit the config.yml file in the root path.</p>\n<p><img src=\"github_config.png\" alt=\"github_config\"></p>\n<p>Download the hexo-deployer-git plugin.</p>\n<pre><code>$ npm install hexo-deployer-git --save\n</code></pre><p>After set up the ssh keys, you should be able to deploy code to github. </p>\n<pre><code>$ hexo g\n$ hexo d\n</code></pre><p>Then, you can view the blog page from github using the url: yourname.github.io</p>\n<h2 id=\"Add-themes-to-your-blog\"><a href=\"#Add-themes-to-your-blog\" class=\"headerlink\" title=\"Add themes to your blog\"></a>Add themes to your blog</h2><p>Download a theme for your blog is easy, you can do it like this:</p>\n<pre><code>$ git clone https://github.com/wuchong/jacman.git themes/jacman\n</code></pre><p>After you execute this command, a theme “jacman” will be intalled to the “themes” folder, and what you need to do is adding to config_yml file, replace the default theme “landscape”.</p>\n<p>More themes would be available in <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo</a>.</p>\n<h2 id=\"Add-new-blog\"><a href=\"#Add-new-blog\" class=\"headerlink\" title=\"Add new blog\"></a>Add new blog</h2><p>At this point, creat a new blog is simply by typing the command</p>\n<pre><code>$ hexo new\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>I have been thinking for a while to create my own personal tech blog to record my tech studies. And I came accross Hexo, a simple blog framework for us to create our own blogs. It’s super helpful for non front-end developers. Here are the steps you can follow.</p>\n<h1 id=\"Steps\"><a href=\"#Steps\" class=\"headerlink\" title=\"Steps\"></a>Steps</h1><h2 id=\"Download-node-js\"><a href=\"#Download-node-js\" class=\"headerlink\" title=\"Download node.js\"></a>Download node.js</h2><p>Here I use node-v5.6.0</p>\n<h2 id=\"Install-Hexo-and-packages\"><a href=\"#Install-Hexo-and-packages\" class=\"headerlink\" title=\"Install Hexo and packages\"></a>Install Hexo and packages</h2><p>Screen Shot 2018-08-20 at 5.34.24 PM<br>    $ npm install -g hexo<br>    $ hexo init<br>    $ npm install</p>\n<p>You will be able to view the default blog page (localhost:4000) generated by hexo locally after type in,</p>\n<pre><code>$ hexo g \n$ hexo s\n</code></pre><h2 id=\"Deploy-code-to-github\"><a href=\"#Deploy-code-to-github\" class=\"headerlink\" title=\"Deploy code to github\"></a>Deploy code to github</h2><p>You need to create a github repository following the naming pattern: “yourname.github.io”, then edit the config.yml file in the root path.</p>\n<p><img src=\"github_config.png\" alt=\"github_config\"></p>\n<p>Download the hexo-deployer-git plugin.</p>\n<pre><code>$ npm install hexo-deployer-git --save\n</code></pre><p>After set up the ssh keys, you should be able to deploy code to github. </p>\n<pre><code>$ hexo g\n$ hexo d\n</code></pre><p>Then, you can view the blog page from github using the url: yourname.github.io</p>\n<h2 id=\"Add-themes-to-your-blog\"><a href=\"#Add-themes-to-your-blog\" class=\"headerlink\" title=\"Add themes to your blog\"></a>Add themes to your blog</h2><p>Download a theme for your blog is easy, you can do it like this:</p>\n<pre><code>$ git clone https://github.com/wuchong/jacman.git themes/jacman\n</code></pre><p>After you execute this command, a theme “jacman” will be intalled to the “themes” folder, and what you need to do is adding to config_yml file, replace the default theme “landscape”.</p>\n<p>More themes would be available in <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo</a>.</p>\n<h2 id=\"Add-new-blog\"><a href=\"#Add-new-blog\" class=\"headerlink\" title=\"Add new blog\"></a>Add new blog</h2><p>At this point, creat a new blog is simply by typing the command</p>\n<pre><code>$ hexo new\n</code></pre>"},{"title":"线程安全性-可见性","date":"2018-09-01T11:37:55.000Z","_content":"\n# 可见性\n\n导致共享变量在线程间不可见的原因\n\n1. 线程交叉执行\n2. 重排序\n3. 共享变量更新后的值没有在工作内存和主内存及时更新\n\n## JMM关于synchronized的规定\n\n1. 线程解锁前， 必须把共享变量最新值刷新到主内存\n2. 线程加锁前， 将清空工作变量中共享变量的值， 从而使用时需要从主内存重新读取最新的值\n\n## volatile\n\n通过加入内存屏障和禁止重排序优化来实现\n对volatile变量写操作时， 会在写操作后加入一条store屏障指令， 将本地内存中的共享变量刷新到主内存\n对volatile变量读操作时， 会在读操作前加入一条load屏障指令， 从内存中读取共享变量\n\n![reorder_read](reorder_read.png)\n![MESI Protocal](reorder_write.png)\n","source":"_posts/线程安全性-可见性.md","raw":"---\ntitle: 线程安全性-可见性\ndate: 2018-09-01 19:37:55\ntags:\n---\n\n# 可见性\n\n导致共享变量在线程间不可见的原因\n\n1. 线程交叉执行\n2. 重排序\n3. 共享变量更新后的值没有在工作内存和主内存及时更新\n\n## JMM关于synchronized的规定\n\n1. 线程解锁前， 必须把共享变量最新值刷新到主内存\n2. 线程加锁前， 将清空工作变量中共享变量的值， 从而使用时需要从主内存重新读取最新的值\n\n## volatile\n\n通过加入内存屏障和禁止重排序优化来实现\n对volatile变量写操作时， 会在写操作后加入一条store屏障指令， 将本地内存中的共享变量刷新到主内存\n对volatile变量读操作时， 会在读操作前加入一条load屏障指令， 从内存中读取共享变量\n\n![reorder_read](reorder_read.png)\n![MESI Protocal](reorder_write.png)\n","slug":"线程安全性-可见性","published":1,"updated":"2018-09-03T05:52:30.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l06w0006hcr0k4y2r4pq","content":"<h1 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h1><p>导致共享变量在线程间不可见的原因</p>\n<ol>\n<li>线程交叉执行</li>\n<li>重排序</li>\n<li>共享变量更新后的值没有在工作内存和主内存及时更新</li>\n</ol>\n<h2 id=\"JMM关于synchronized的规定\"><a href=\"#JMM关于synchronized的规定\" class=\"headerlink\" title=\"JMM关于synchronized的规定\"></a>JMM关于synchronized的规定</h2><ol>\n<li>线程解锁前， 必须把共享变量最新值刷新到主内存</li>\n<li>线程加锁前， 将清空工作变量中共享变量的值， 从而使用时需要从主内存重新读取最新的值</li>\n</ol>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>通过加入内存屏障和禁止重排序优化来实现<br>对volatile变量写操作时， 会在写操作后加入一条store屏障指令， 将本地内存中的共享变量刷新到主内存<br>对volatile变量读操作时， 会在读操作前加入一条load屏障指令， 从内存中读取共享变量</p>\n<p><img src=\"reorder_read.png\" alt=\"reorder_read\"><br><img src=\"reorder_write.png\" alt=\"MESI Protocal\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h1><p>导致共享变量在线程间不可见的原因</p>\n<ol>\n<li>线程交叉执行</li>\n<li>重排序</li>\n<li>共享变量更新后的值没有在工作内存和主内存及时更新</li>\n</ol>\n<h2 id=\"JMM关于synchronized的规定\"><a href=\"#JMM关于synchronized的规定\" class=\"headerlink\" title=\"JMM关于synchronized的规定\"></a>JMM关于synchronized的规定</h2><ol>\n<li>线程解锁前， 必须把共享变量最新值刷新到主内存</li>\n<li>线程加锁前， 将清空工作变量中共享变量的值， 从而使用时需要从主内存重新读取最新的值</li>\n</ol>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>通过加入内存屏障和禁止重排序优化来实现<br>对volatile变量写操作时， 会在写操作后加入一条store屏障指令， 将本地内存中的共享变量刷新到主内存<br>对volatile变量读操作时， 会在读操作前加入一条load屏障指令， 从内存中读取共享变量</p>\n<p><img src=\"reorder_read.png\" alt=\"reorder_read\"><br><img src=\"reorder_write.png\" alt=\"MESI Protocal\"></p>\n"},{"title":"线程安全性-有序性","date":"2018-09-02T02:30:53.000Z","_content":"\n# 有序性\n\njava内存模型， 允许编译器和处理器对指令重排序， 重排序结果不会影响单线程执行， 却会影响到多线程并发执行的正确性。\n\nsynchronized, lock同一时间只允许一个线程执行同步代码， 让线程们顺序执行当然保证了有序性\n\nvolatile也能保证一定的有序性\n\n\n## Happens-before原则\n\nJMM先天的有序性（不需要通过任何手段就能保证的有序性）\n * 程序次序原则， 代码按书写次序执行（适用于单线程， 逻辑上看是按次序执行的， 因为有重排序）\n * 锁定原则， unlock先行发生于lock\n * volatile变量规则， 对一个变量的写操作先行发生于读操作\n * 传递规则\n 。。。 \n 后面的4条都很显而易见","source":"_posts/线程安全性-有序性.md","raw":"---\ntitle: 线程安全性-有序性\ndate: 2018-09-02 10:30:53\ntags:\n---\n\n# 有序性\n\njava内存模型， 允许编译器和处理器对指令重排序， 重排序结果不会影响单线程执行， 却会影响到多线程并发执行的正确性。\n\nsynchronized, lock同一时间只允许一个线程执行同步代码， 让线程们顺序执行当然保证了有序性\n\nvolatile也能保证一定的有序性\n\n\n## Happens-before原则\n\nJMM先天的有序性（不需要通过任何手段就能保证的有序性）\n * 程序次序原则， 代码按书写次序执行（适用于单线程， 逻辑上看是按次序执行的， 因为有重排序）\n * 锁定原则， unlock先行发生于lock\n * volatile变量规则， 对一个变量的写操作先行发生于读操作\n * 传递规则\n 。。。 \n 后面的4条都很显而易见","slug":"线程安全性-有序性","published":1,"updated":"2018-09-03T05:52:30.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlm1l06y0007hcr0yqg18uei","content":"<h1 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h1><p>java内存模型， 允许编译器和处理器对指令重排序， 重排序结果不会影响单线程执行， 却会影响到多线程并发执行的正确性。</p>\n<p>synchronized, lock同一时间只允许一个线程执行同步代码， 让线程们顺序执行当然保证了有序性</p>\n<p>volatile也能保证一定的有序性</p>\n<h2 id=\"Happens-before原则\"><a href=\"#Happens-before原则\" class=\"headerlink\" title=\"Happens-before原则\"></a>Happens-before原则</h2><p>JMM先天的有序性（不需要通过任何手段就能保证的有序性）</p>\n<ul>\n<li>程序次序原则， 代码按书写次序执行（适用于单线程， 逻辑上看是按次序执行的， 因为有重排序）</li>\n<li>锁定原则， unlock先行发生于lock</li>\n<li>volatile变量规则， 对一个变量的写操作先行发生于读操作</li>\n<li>传递规则<br>。。。<br>后面的4条都很显而易见</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h1><p>java内存模型， 允许编译器和处理器对指令重排序， 重排序结果不会影响单线程执行， 却会影响到多线程并发执行的正确性。</p>\n<p>synchronized, lock同一时间只允许一个线程执行同步代码， 让线程们顺序执行当然保证了有序性</p>\n<p>volatile也能保证一定的有序性</p>\n<h2 id=\"Happens-before原则\"><a href=\"#Happens-before原则\" class=\"headerlink\" title=\"Happens-before原则\"></a>Happens-before原则</h2><p>JMM先天的有序性（不需要通过任何手段就能保证的有序性）</p>\n<ul>\n<li>程序次序原则， 代码按书写次序执行（适用于单线程， 逻辑上看是按次序执行的， 因为有重排序）</li>\n<li>锁定原则， unlock先行发生于lock</li>\n<li>volatile变量规则， 对一个变量的写操作先行发生于读操作</li>\n<li>传递规则<br>。。。<br>后面的4条都很显而易见</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/并发基本概念/JMM.png","slug":"JMM.png","post":"cjlm1l0340002hcr05bg4cre0","modified":1,"renderable":0},{"_id":"source/_posts/Hexo-blog-framework/github_config.png","post":"cjlm1l0370005hcr0kveji83l","slug":"github_config.png","modified":1,"renderable":1},{"_id":"source/_posts/并发基本概念/JMM_caozuo.png","post":"cjlm1l0340002hcr05bg4cre0","slug":"JMM_caozuo.png","modified":1,"renderable":1},{"_id":"source/_posts/并发基本概念/MESI_protocal.jpg","post":"cjlm1l0340002hcr05bg4cre0","slug":"MESI_protocal.jpg","modified":1,"renderable":1},{"_id":"source/_posts/并发基本概念/ad_disad.png","slug":"ad_disad.png","post":"cjlm1l0340002hcr05bg4cre0","modified":1,"renderable":0},{"_id":"source/_posts/线程安全性-可见性/reorder_read.png","post":"cjlm1l06w0006hcr0k4y2r4pq","slug":"reorder_read.png","modified":1,"renderable":1},{"_id":"source/_posts/线程安全性-可见性/reorder_write.png","post":"cjlm1l06w0006hcr0k4y2r4pq","slug":"reorder_write.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}