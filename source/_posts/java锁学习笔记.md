---
title: java锁学习笔记
date: 2018-12-24 15:16:59
tags:
---

# 内置锁基本问题

## 重量级锁

内置锁及重量级锁在java中被抽象为监视器锁（monitor）在JDK1.6之前可以直接对底层操作系统中的互斥量（mutex）进行操作。 这种同步方式成本很高， 包括系统调用引起的**内核态**与**用户态**切换、线程阻塞造成的**线程切换**等 

## 自旋锁

内核态用户态切换不易优化， 通过自旋锁， 可以**减少线程阻塞造成的线程切换**（包括挂起线程和恢复线程）

如果锁的粒度小， 那么锁持有时间短。 那么对于竞争这些锁而言， 因为锁阻塞造成线程切换的时间与锁持有的时间相当， 减少线程阻塞造成的线程切换， 能提高性能。

1. 当前线程竞争锁失败， 打算阻塞自己
2. 不阻塞， 自旋
3. 自旋同时重新竞争锁
4. 如果自旋结束前获得锁，则运行； 否则， 自旋结束后阻塞自己

### 缺点

1. 单核处理器， 或者线程多处理器少， 自旋会造成不少无畏的浪费
2. 自旋要占用cpu， 对于**计算密集型任务**， 这一优化通常得不偿失， 减少锁的使用时更好选择
3. 锁持有时间长， 竞争激烈的场景中， 应该主动禁用自旋锁


## 自适应自旋锁

自适应意味自旋的时间不再固定了， 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定：
自适应自旋锁解决的是**锁竞争时间不确定**的问题。 JVM很难知道确切的锁竞争时间， 而交给用户分析就违反了JVM设计的初衷。 自适应自旋锁假定不同线程持有同一个锁对象的时间基本相同， 竞争程度趋于稳定， 因此， 可以根据上一次自旋的时间与结果调整下一次自旋的时间

### 缺点
如果默认的自旋次数设置不合理（过高或者过低）， 那么自适应过程很难收敛到合适的值

## 轻量级锁
轻量级锁的目的是： **减少无实际竞争情况下， 使用重量级锁产生的性能消耗** 包括系统调用引起的内核态和用户态切换、线程阻塞造成的线程切换等。

使用轻量级锁， 不需要申请互斥量， 而是使用CAS更新指向线程栈中的Lock Record, 如果更新成功则获取轻量级锁成功； 否则说明发生竞争， 膨胀为重量级锁

### 缺点
同自旋锁类似， 如果竞争激烈， 锁很快就膨胀为重量级锁， 维持轻量级锁的过程就浪费了

## 偏向锁
减少无竞争且只有一个线程使用锁情况下， 使用轻量级锁产生的性能消耗。 轻量级锁每次申请、释放锁都至少需要一次CAS， 但偏向锁只有初始化需要一次CAS
之后当前线程可以零成本直接获取锁； 否则， 说明有其他线程竞争， 膨胀为轻量级锁

偏向锁无法使用自旋锁优化， 因为一旦有其他线程申请锁， 就破坏了偏向锁的假定





