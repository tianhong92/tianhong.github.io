---
title: 线程安全性-原子性
date: 2018-08-31 11:26:59
tags:
---

# 线程安全性定义

当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。

线程安全性主要体现在3个方面：
1. 原子性
2. 可见性
3. 有序性


	public class CountExample2 {
    	// 请求总数
    	public static int clientTotal = 5000;
    	// 同时并发执行的线程数
    	public static int threadTotal = 200;
    	public static AtomicInteger count = new AtomicInteger();

    	public static void main(String[] args) throws InterruptedException {
        	ExecutorService executorService = Executors.newCachedThreadPool();
        	// 信号量
        	final Semaphore semaphore = new Semaphore(threadTotal);
        	// 计数器闭锁
        	final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        	for(int i = 0; i < clientTotal; i++){
            	executorService.execute(() -> {
                	try {
                    	// 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞
                    	semaphore.acquire();
                    	add();
                    	semaphore.release();
                	} catch (InterruptedException e) {
                    	e.printStackTrace();
                  	  	log.error("Exception", e);
                	}
                		// 执行完一次， 计数值减一
                		countDownLatch.countDown();
            	});
        	}
        	// 保证countdownLatch必须减为0， 这表明所有线程都执行完
        	countDownLatch.await();
        	executorService.shutdown();
        	log.info("Count:{}", count.get());
    	}

    	private static void add(){
        	count.incrementAndGet();
    	}
	}

AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）比较，只有一样才累加。  	

