---
title: 线程安全性-原子性
date: 2018-08-31 11:26:59
tags:
---

# 线程安全性定义

当多个线程访问某个类时， 不管运行时环境采取何种调度方式或者这些线程如果交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出真确的行为， 这个类就是线程安全的。

线程安全性主要体现在3个方面：
1. 原子性
2. 可见性
3. 有序性

# 原子性实现

## AtomicXXX, CAS 

比如AtomicInteger类主要用到CAS的方式， 具体用到compareAndSwapInt函数， 累加前当前值（工作内存）和底层的值（主内存）需要比较，只有一样才累加。  并发环境下CAS失败率高， 一个线程的原子操作可能循环多次尝试，影响性能。  	


## AtomicLong, LongAdder

JDK8新增了LongAdder, 和AtomicLong有相似点。 LongAdder有优点，把热点数据分离， 把AtomicLong内部核心数据value被分为一个数组（多个cell）。 每个线程访问时候根据哈希等方法映射到一个节点进行计数。 最终结果为各个节点数据求和累加。 LongAdder等于把AtomicLong单点的更新压力分散到多个节点上。 低并发环境下通过对base的直接更新可以保证和AtomicLong效率基本相同。
缺点是统计时候如果有并发更新统计数据可能会有误差。 如果要生成全局唯一的序列号就不适合用LongAdder。

## AtomicReference, AtomicReferenceFieldUpdater

	public class AtomicReferenceExample {
    	private static AtomicReference<Integer> count = new AtomicReference(0);
    	public static void main(String[] args) {
        	count.compareAndSet(0, 2);
        	count.compareAndSet(2, 4);
        	log.info("count: {}", count.get());
    	}
	}


	public class AtomicFieldUpdaterExample {
    	private static AtomicIntegerFieldUpdater<AtomicFieldUpdaterExample> updater =
            AtomicIntegerFieldUpdater.newUpdater(AtomicFieldUpdaterExample.class, "count");
    	@Getter
    	public volatile int count = 100;

    	public static void main(String[] args) {
        	AtomicFieldUpdaterExample example = new AtomicFieldUpdaterExample();
        	if(updater.compareAndSet(example, 100, 120)) {
            	log.info("update success 1, {}", example.getCount());
        	}
        	if(updater.compareAndSet(example, 100, 120)){
            	log.info("update success 2, {}", example.getCount());
        	} else {
            	log.info("update fail, {}", example.getCount());
        	}
    	}
	}
	只能更新非static的volatile变量


## AtomicStampReference: CAS的ABA问题

一个线程把变量A变为B又变回A， 这时候需要维护一个变化的Stamp来反映变量确实变化过。

