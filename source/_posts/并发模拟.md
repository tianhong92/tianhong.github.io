---
title: 简单并发场景模拟
date: 2018-08-30 21:43:30
tags:
---

## Postman

Http请求模拟工具， 也能模拟并发， 但是不是很专业

## Apache Bench (AB)

Apache附带的工具， 测试网站性能， 简单好用， 没有强大的图形界面支持

## JMeter

Apache开发的压力测试工具

## 并发模拟代码

模拟多线程并发累加count计数器变量。

### Semaphore

用到Semaphore信号量来模拟同时允许多少线程执行， 如果不能获取信号量， 线程就阻塞。 Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。 线程运行时首先获取许可permits, 如果成功， 书可数减1， 如果线程运行完释放许可， 许可数就加1. 许可数为0， 则获取失败。 

### CountDownLatch

CountDownLatch模拟计数器闭锁， 赋值为总的请求数， 每个请求执行完countdown一次。 await操作能被执行说明所有线程执行完。 一个典型的应用场景是启动一个服务时， 主线程需要等待多个组件加载完毕， 之后再继续执行。



	public class ConcurrencyTest {
    	// 请求总数
    	public static int clientTotal = 5000;
    	// 同时并发执行的线程数
    	public static int threadTotal = 200;

    	public static int count = 0;
    	public static void main(String[] args) throws InterruptedException {
        	ExecutorService executorService = Executors.newCachedThreadPool();
        	// 信号量
        	final Semaphore semaphore = new Semaphore(threadTotal);
        	// 计数器闭锁
        	final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        	for(int i = 0; i < clientTotal; i++){
            	executorService.execute(() -> {
                	try {
                    	// 信号量模拟同时允许多少个线程执行， 达到一定并发数add会被阻塞
                    	semaphore.acquire();
                    	add();
                    	semaphore.release();
                	} catch (InterruptedException e) {
                    	e.printStackTrace();
                    	log.error("Exception", e);
                	}
                	// 执行完一次， 计数值减一
                	countDownLatch.countDown();
            	});
        	}
        	// 保证countdownLatch必须减为0， 这表明所有线程都执行完
        	countDownLatch.await();
        	executorService.shutdown();
        	log.info("Count:{}", count);
    	}
    	private static void add(){
        	count++;
    	}
	}


每次执行结果count值会变， 说明存在并发问题。
	

